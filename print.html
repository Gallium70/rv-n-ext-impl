<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Risc-V Extension N Implementation</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> 简介</a></li><li class="chapter-item expanded "><a href="ch1_0_background.html"><strong aria-hidden="true">2.</strong> 项目背景与现有工作</a></li><li class="chapter-item expanded "><a href="ch2_0_design.html"><strong aria-hidden="true">3.</strong> 系统设计</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch2_1_n_ext_spec.html"><strong aria-hidden="true">3.1.</strong> N 扩展规范草案</a></li><li class="chapter-item expanded "><a href="ch2_2_user_trap_handle_flow.html"><strong aria-hidden="true">3.2.</strong> 用户态中断的处理流程</a></li><li class="chapter-item expanded "><a href="ch2_3_external_interrupt_and_plic.html"><strong aria-hidden="true">3.3.</strong> 外部中断与 PLIC</a></li><li class="chapter-item expanded "><a href="ch2_4_n_ext_on_qemu_and_fpga.html"><strong aria-hidden="true">3.4.</strong> QEMU 和 FPGA 中的 N 扩展支持</a></li><li class="chapter-item expanded "><a href="ch2_5_bootloader.html"><strong aria-hidden="true">3.5.</strong> 启动器与 SBI</a></li><li class="chapter-item expanded "><a href="ch2_6_user_trap_management.html"><strong aria-hidden="true">3.6.</strong> 内核对用户态中断的管理</a></li><li class="chapter-item expanded "><a href="ch2_7_user_trap_usage.html"><strong aria-hidden="true">3.7.</strong> 用户态中断扩展的使用</a></li><li class="chapter-item expanded "><a href="ch2_8_rcore_n_smp.html"><strong aria-hidden="true">3.8.</strong> rCore-N 的多核改造</a></li></ol></li><li class="chapter-item expanded "><a href="ch3_0_user_guide.html"><strong aria-hidden="true">4.</strong> 使用教程</a></li><li class="chapter-item expanded "><a href="ch4_0_test_and_demo.html"><strong aria-hidden="true">5.</strong> 系统测试与演示程序</a></li><li class="chapter-item expanded "><a href="ch5_0_plan_and_progress.html"><strong aria-hidden="true">6.</strong> 开发计划与进展</a></li><li class="chapter-item expanded "><a href="ch6_0_problem_and_solutions.html"><strong aria-hidden="true">7.</strong> 遇到的主要问题和解决方法</a></li><li class="chapter-item expanded "><a href="ch7_0_cooperation.html"><strong aria-hidden="true">8.</strong> 分工与协作</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Risc-V Extension N Implementation</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="软硬协同的用户态中断"><a class="header" href="#软硬协同的用户态中断">软硬协同的用户态中断</a></h1>
<h2 id="目标"><a class="header" href="#目标">目标</a></h2>
<p>本项目在现有 <a href="https://five-embeddev.com/riscv-isa-manual/latest/n.html">RISC-V 用户态中断扩展规范草案</a> 的基础上将其进一步完善，提出一种符合该规范的模拟器和 FPGA 实现，并基于用户态中断在内核中实现优化的信号机制，在用户态实现一个硬件驱动，展示其设计和性能优势。</p>
<h2 id="系统设计"><a class="header" href="#系统设计">系统设计</a></h2>
<p>系统整体架构设计如下：</p>
<p><img src="assets/proj.svg" alt="arch" /></p>
<ul>
<li>模拟器：修改 QEMU 5.0，在其中添加 N 扩展支持</li>
<li>FPGA：基于中科院计算所的<a href="https://github.com/LvNA-system/labeled-RISC-V/tree/master/fpga">标签化 RISC-V 架构</a>，添加 N 扩展支持</li>
<li>启动器与 SBI：在 FPGA 平台上使用基于 RustSBI 开发的 <a href="https://github.com/Gallium70/lrv-rust-bl">lrv-rust-bl</a> ，在 QEMU 上使用修改过的 <a href="https://github.com/duskmoon314/rustsbi-qemu/tree/legacy-multicore">RustSBI-QEMU</a> 以提供多核启动支持</li>
<li>操作系统：<a href="https://github.com/duskmoon314/rCore-N">rCore-N</a>，能够在多核环境下运行，演示程序也在该仓库中</li>
</ul>
<h3 id="仓库目录和结构"><a class="header" href="#仓库目录和结构">仓库目录和结构</a></h3>
<pre><code>.
├── README.md
├── docs                docs in mdbook structure
├── Labeled-RISC-V-N    Labeled RISC-V with N extension, FPGA code
├── lrv-rust-bl         Labeled RISC-V fpga bootloader based on RustSBI
├── qemu                qemu modified by Campbell He
├── qemu-build          folder holding qemu build artifacts
├── rCore-N             rCore with N extension
├── rustsbi-qemu        rustsbi-qemu with legacy IPI and multicore boot support
└── rv-csr-test         N extension simple test program
</code></pre>
<h2 id="部分开发进展"><a class="header" href="#部分开发进展">部分开发进展</a></h2>
<h3 id="qemu-与-fpga"><a class="header" href="#qemu-与-fpga">QEMU 与 FPGA</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
在 QEMU 中添加 N 扩展支持</li>
<li><input disabled="" type="checkbox" checked=""/>
在 FPGA 开发板上部署标签化 RISC-V 架构</li>
<li><input disabled="" type="checkbox" checked=""/>
在标签化 RISC-V 架构中添加 N 扩展支持
<ul>
<li><input disabled="" type="checkbox" checked=""/>
通过基本测试</li>
<li><input disabled="" type="checkbox" checked=""/>
单核情况下正常运行 rCore-N</li>
<li><input disabled="" type="checkbox" checked=""/>
多核启动和运行</li>
</ul>
</li>
<li><input disabled="" type="checkbox" checked=""/>
在 QEMU 和 FPGA 中添加额外的串口供用户态程序使用</li>
</ul>
<h3 id="操作系统"><a class="header" href="#操作系统">操作系统</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
实现对用户态中断的管理</li>
<li><input disabled="" type="checkbox" checked=""/>
适配 FPGA 平台</li>
<li><input disabled="" type="checkbox" checked=""/>
多核支持</li>
<li><input disabled="" type="checkbox" checked=""/>
实现信号机制</li>
</ul>
<h3 id="应用程序"><a class="header" href="#应用程序">应用程序</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
验证 N 扩展正常工作</li>
<li><input disabled="" type="checkbox" checked=""/>
信号机制演示程序</li>
<li><input disabled="" type="checkbox" checked=""/>
用户态串口驱动程序</li>
<li><input disabled="" type="checkbox"/>
性能测试</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="项目背景与现有工作"><a class="header" href="#项目背景与现有工作">项目背景与现有工作</a></h1>
<h2 id="risc-v-的特权级与陷入架构"><a class="header" href="#risc-v-的特权级与陷入架构">RISC-V 的特权级与陷入架构</a></h2>
<h3 id="特权级"><a class="header" href="#特权级">特权级</a></h3>
<p>RISC-V 指令集规范将 CPU 的运行状态划分为 4 个特权级模式（暂不考虑调试模式）：Machine、Hypervisor、Supervisor、User。M 态为最高的特权级，也是所有 RISC-V 平台必须实现的特权级，M 态下的指令对 CPU 有完全的控制权；H 态目前在规范中为保留状态，主要为虚拟机应用提供硬件支持，另有专门的 H 扩展描述其行为；S 态为通常的操作系统运行的特权级，U 态则为用户程序运行的特权级。</p>
<p>在实现了地址空间隔离的平台上，M 态程序不受地址空间限制，始终使用物理地址访问内存，除非将 mstatus.MPRV 置位；S 态程序可以通过 satp 寄存器控制分页模式和页表基址，通常在初始化完成后运行在虚拟地址上；U 态程序则完全运行在虚拟地址空间中，受页表权限控制位的限制，且无权访问和修改 satp 寄存器的内容。</p>
<h3 id="陷入"><a class="header" href="#陷入">陷入</a></h3>
<p>RISC-V 将陷入（trap）分为同步的异常（exception）和异步的中断（interrupt），异常由指令执行产生，而中断通常来源于指令之外的因素，如时钟、外设等。中断分为外部中断、时钟中断、软件中断，分别记为 xEI、xTI、xSI，其中x为特权级；这三者在每个特权级下有不同的中断编号，因而 M 态的时钟中断和 S 态的时钟中断不是同一个中断。
与之相对的是，异常在不同特权级下编号相同，因为异常源于指令执行，而指令执行时系统一定具有确定的特权级。</p>
<p>中断的使能和屏蔽由 xstatus.xIE 位和 xie 寄存器控制，前者为当前特权级下的全局中断使能，后者可以独立控制每种中断的使能情况。待处理中断在 xip 寄存器中相应的位为 1 。
注意到低特权级的 status、ie、ip 寄存器均为相应高特权级寄存器的子集，即高特权级可以查看和修改低特权级的中断控制信息，但反过来不行，如 S 态和 M 态的程序均可以通过清除 sie.STIE 来屏蔽 S 态的时钟中断，但 S 态程序不能访问或修改 mie.MTIE 位来影响 M 态时钟中断的行为。</p>
<p>默认情况下所有陷入都由最高特权级（即 M 态）的程序来处理，高特权级的程序可以再将其转交给低特权级处理，通过将 xtval、xepc、xcause 写入相应的低特权级寄存器，清除 xip 寄存器中的相应位，再将低特权级的 tvec 移入 xepc 中，执行 xret 指令，即进入到低特权级的中断处理程序。</p>
<p>为了提高中断处理效率，RISC-V 提供陷入委托机制，允许陷入在较低特权级处理，相应的控制寄存器为 xideleg 和 xedeleg。不能将高特权级的陷入委托给低特权级，同时对于已经委托的陷入，在高特权级下将被忽略，直至返回低特权级时才进行处理。如 mideleg 中 MTI、MEI、MSI 的相应位恒为 0，不能委托，而将 mideleg.STI 置为 1 则将 S 态的时钟中断委托给 S 态处理，此时即使 mip.STIP 为 1，M 态也不会进入中断处理程序。</p>
<h2 id="risc-v-的-n-扩展草案"><a class="header" href="#risc-v-的-n-扩展草案">RISC-V 的 N 扩展草案</a></h2>
<p>在 RISC-V 特权级指令规范中，曾经存在一章 N 扩展草案，即用户态中断扩展。该扩展设计的主要目标是为嵌入式系统提供更好的安全支持，后者可以实现 M 和 U 两个特权级，将“不可信”代码置于 U 态执行，同时通过中断委托机制允许其直接处理中断。
在类 Unix 系统上，该扩展主要希望为整数溢出、浮点异常、垃圾回收等发生在用户态的事件（及相应的扩展）提供支持。</p>
<p>然而有另一部分观点认为，在嵌入式系统上，使用 M 和 S 两个特权级可以实现同样的功能，只需将 satp 寄存器由硬件置为 0 ；而对于 Unix 环境下，N 扩展的应用场景尚不明朗，长期以来也几乎无人推动 N 扩展的完善。最终，在最近的 RISC-V 规范草案中，N 扩展被移除，其他部分关于用户态中断的表述也相应降级。</p>
<h2 id="risc-v-中断相关的扩展与规范"><a class="header" href="#risc-v-中断相关的扩展与规范">RISC-V 中断相关的扩展与规范</a></h2>
<p>中断控制器的设计不在 RISC-V 指令集规范的范畴内，目前仅 PLIC(Platform-Level Interrupt Controller) 有一个兼容性标准。一种常见的设计是 CLINT(Core-Local Interruptor) 搭配 PLIC，前者提供时钟中断和跨核软件中断支持，后者管理外设产生的中断。</p>
<p>除 CLINT 和 PLIC 之外，RISC-V 还有 CLIC(Core Local Interrupt Controller)、ACLINT(Advanced CLINT)、AIA(Advanced Interrupt Archetecture) 等扩展草案。其中 CLIC 提供低延迟、向量化、可抢占的中断系统，在草案中明确可以与 N 扩展兼容；ACLINT 为 CLINT 扩展，目前可以提供 S 态的跨核中断；AIA 主要提供对 PCIe 标准中的消息信号中断 (Message-Signaled Interrupt) 机制支持。后两者没有明确与用户态中断的兼容性。</p>
<h2 id="linux-中的信号机制"><a class="header" href="#linux-中的信号机制">Linux 中的信号机制</a></h2>
<p>信号是 Linux 中的一种基本的 IPC 机制，当进程从内核态返回用户态时，如果有待处理的信号，内核将在用户栈上构造一个信号上下文，调用用户的信号处理函数；信号处理完成后，由跳板代码再调用 sys_sigreturn() ，进入内核中，恢复进程的正常执行流的上下文，返回用户态，进程继续执行。</p>
<p>站在用户程序的视角，信号与中断机制有诸多相似之处：产生的时间不确定、会中断当前执行流、通常需要额外的上下文切换。可以说信号是由内核软件模拟的一种中断机制。</p>
<h2 id="用户态驱动"><a class="header" href="#用户态驱动">用户态驱动</a></h2>
<p>在 Linux 系统中，大部分硬件驱动位于内核代码仓库中，与内核共同编译、运行。这种设计在安全性、扩展性、可维护性均存在一定的问题。尽管与微内核中，调用驱动需要经过 IPC 的方式相比，将驱动放在内核态的性能通常较高，但仍然存在系统调用带来的上下文切换开销，在频繁访问外设时会带来显著的性能下降。</p>
<p>为了进一步提高性能，一些实现方案（如 SPDK ）将硬件驱动完全移入用户态，作为应用程序的一部分。通过将外设的内核驱动重新绑定到 uio 或 vfio ，用户进程可以直接访问外设的地址空间，操作外设，省去了系统调用和 IPC 的开销。这些方案通常是基于轮询实现的，因为现有的硬件基本不支持将外设中断交由用户态程序处理，且中断可能带来性能波动。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="系统设计-1"><a class="header" href="#系统设计-1">系统设计</a></h1>
<p>本章将介绍我们对于本项目的设计思路，即我们“为什么”要这么做。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="n-扩展规范草案----omit-in-toc---"><a class="header" href="#n-扩展规范草案----omit-in-toc---">N 扩展规范草案 <!-- omit in toc --></a></h1>
<p>本节描述 N 扩展的 CPU 设计规范草案，即支持 N 扩展的 CPU 需要添加哪些寄存器和指令。关于用户态中断的流程和使用请参见后文。</p>
<blockquote>
<p>目前此扩展适用于实现了 M/S/U 三种特权级和 CLINT+PLIC 的系统，暂不考虑与 H 扩展以及 AIA、CLIC、ACLINT 等中断机制的兼容或适配。</p>
</blockquote>
<ul>
<li><a href="ch2_1_n_ext_spec.html#n-%E6%89%A9%E5%B1%95%E7%9A%84-csr">N 扩展的 CSR</a>
<ul>
<li><a href="ch2_1_n_ext_spec.html#%E7%94%A8%E6%88%B7%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8-ustatus">用户状态寄存器 (<code>ustatus</code>)</a></li>
<li><a href="ch2_1_n_ext_spec.html#%E7%94%A8%E6%88%B7%E9%99%B7%E5%85%A5%E5%90%91%E9%87%8F%E5%9F%BA%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8-utvec">用户陷入向量基址寄存器 (<code>utvec</code>)</a></li>
<li><a href="ch2_1_n_ext_spec.html#%E7%94%A8%E6%88%B7%E4%B8%AD%E6%96%AD%E5%AF%84%E5%AD%98%E5%99%A8-uip-%E4%B8%8E-uie">用户中断寄存器 (<code>uip</code> 与 <code>uie</code>)</a></li>
<li><a href="ch2_1_n_ext_spec.html#%E5%86%85%E6%A0%B8%E6%80%81%E9%99%B7%E5%85%A5%E5%A7%94%E6%89%98%E5%AF%84%E5%AD%98%E5%99%A8-sedeleg-%E4%B8%8E-sideleg">内核态陷入委托寄存器 (<code>sedeleg</code> 与 <code>sideleg</code>)</a></li>
<li><a href="ch2_1_n_ext_spec.html#uscratch">uscratch</a></li>
<li><a href="ch2_1_n_ext_spec.html#%E7%94%A8%E6%88%B7%E5%BC%82%E5%B8%B8%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8-uepc">用户异常程序计数器 (<code>uepc</code>)</a></li>
<li><a href="ch2_1_n_ext_spec.html#%E7%94%A8%E6%88%B7%E9%99%B7%E5%85%A5%E5%8E%9F%E5%9B%A0%E5%AF%84%E5%AD%98%E5%99%A8-ucause">用户陷入原因寄存器 (<code>ucause</code>)</a></li>
<li><a href="ch2_1_n_ext_spec.html#%E7%94%A8%E6%88%B7%E9%99%B7%E5%85%A5%E5%80%BC%E5%AF%84%E5%AD%98%E5%99%A8-utval">用户陷入值寄存器 (<code>utval</code>)</a></li>
</ul>
</li>
<li><a href="ch2_1_n_ext_spec.html#n-%E6%89%A9%E5%B1%95%E7%9A%84%E6%8C%87%E4%BB%A4">N 扩展的指令</a>
<ul>
<li><a href="ch2_1_n_ext_spec.html#uret">URET</a></li>
</ul>
</li>
</ul>
<h2 id="n-扩展的-csr"><a class="header" href="#n-扩展的-csr">N 扩展的 CSR</a></h2>
<p>与 M 和 S 态类似，U 态也有一系列存储中断相关信息的寄存器。</p>
<h3 id="用户状态寄存器-ustatus"><a class="header" href="#用户状态寄存器-ustatus">用户状态寄存器 (<code>ustatus</code>)</a></h3>
<pre><code>UXLEN-1 5   4    3  1    0
┌────────┬──────┬──────┬─────┐
│  WPRI  │ UPIE │ WPRI │ UIE │
└────────┴──────┴──────┴─────┘
  UXLEN-5   1       3     1
</code></pre>
<p><code>ustatus</code> 是一个 UXLEN 位长的可读写寄存器，记录和控制硬件线程当前的工作状态。</p>
<p>用户态中断使能位 UIE 为零时，用户态中断被禁用。为了向用户态陷入处理程序提供原子性，UIE 中的值在用户态中断发生时被复制到 UPIE ，且 UIE 被置为零。</p>
<p>UIE 和 UPIE 是 <code>mstatus</code> 和 <code>sstatus</code> 中对应位的镜像。</p>
<blockquote>
<p>进入用户态中断处理函数之前的特权级只可能是用户态，所以不需要 UPP 位。</p>
</blockquote>
<p>指令 URET 用于从用户态陷入状态中返回。URET 将 UPIE 复制回 UIE，然后将 UPIE 置位，最后将 <code>uepc</code> 拷贝至 <code>pc</code>。</p>
<blockquote>
<p>在 UPIE/UIE 栈弹出后置位 UPIE 是为了启用中断，以及帮助发现代码中的错误。</p>
</blockquote>
<h3 id="用户陷入向量基址寄存器-utvec"><a class="header" href="#用户陷入向量基址寄存器-utvec">用户陷入向量基址寄存器 (<code>utvec</code>)</a></h3>
<pre><code>| BASE[UXLEN-1 : 2] | MODE |
</code></pre>
<p><code>utvec</code> 是 UXLEN 位长的可读写寄存器，存储陷入向量的设置，包括向量基址 (BASE) 和向量模式。</p>
<p><code>utvec</code> 中的 BASE 为 <strong>WARL</strong> 字段，可以存储任何有效的虚拟地址或物理地址，地址需要对齐到 4 字节。其他的向量模式可能有额外的对齐约束条件。</p>
<table><thead><tr><th>value</th><th>name</th><th>description</th></tr></thead><tbody>
<tr><td>0</td><td>direct</td><td>base</td></tr>
<tr><td>1</td><td>vectored</td><td>base + 4 * cause</td></tr>
<tr><td></td><td></td><td>reserved</td></tr>
</tbody></table>
<h3 id="用户中断寄存器-uip-与-uie"><a class="header" href="#用户中断寄存器-uip-与-uie">用户中断寄存器 (<code>uip</code> 与 <code>uie</code>)</a></h3>
<p><code>uip</code> 和 <code>uie</code> 均为 UXLEN 位的可读写寄存器，其中 <code>uip</code> 存储等待处理的中断信息， <code>uie</code> 存储相应的中断使能位。</p>
<pre><code>UXLEN-1  9    8   7    5    4   3    1    0
| WPRI    | UEIP | WPRI | UTIP | WPRI | USIP |

| WPRI    | UEIE | WPRI | UTIE | WPRI | USIE |
  UXLEN-9     1      3      1      3      1
</code></pre>
<p>定义三种中断：软件中断、时钟中断和外部中断。用户态软件中断通过置位当前硬件线程的 <code>uip</code> 的软件中断等待位 (USIP) 来触发。清零该位可以清除待处理的软件中断。当 <code>uie</code> 中的 USIE 为零时，用户态软件中断被禁用。</p>
<p>ABI 应当提供一种向其他硬件线程发送跨核中断的机制，这最终将置位接收方硬件线程 <code>uip</code> 寄存器的 USIP 位。</p>
<p>除了 USIP， <code>uip</code> 中的其他位在用户态是只读的。</p>
<p>如果 <code>uip</code> 寄存器中的 UTIP 位被置位，将产生一个待处理的用户态时钟中断。当 <code>uie</code> 寄存器中的 UTIE 位被置零时，用户态时钟中断被禁用。ABI 应该提供清除待处理的时钟中断的机制。</p>
<p>如果 <code>uip</code> 寄存器中的 UEIP 位被置位，将产生一个待处理的用户态外部中断。当 <code>uie</code> 寄存器中的 UEIE 位被置位时，用户态外部中断被禁用。ABI 应该提供屏蔽、解除屏蔽和查询外部中断原因的机制。</p>
<p><code>uip</code> 和 <code>uie</code> 寄存器是 <code>mip</code> 和 <code>mie</code> 寄存器的子集。对 <code>uip</code>/<code>uie</code> 任何字段的读取或写入操作，都会等效为对 <code>mip</code>/<code>mie</code> 的相应字段的读取或写入。如果系统实现了 S 模式，<code>uip</code> 和 <code>uie</code> 寄存器也是 <code>sip</code> 和 <code>sie</code> 寄存器的子集。</p>
<h3 id="内核态陷入委托寄存器-sedeleg-与-sideleg"><a class="header" href="#内核态陷入委托寄存器-sedeleg-与-sideleg">内核态陷入委托寄存器 (<code>sedeleg</code> 与 <code>sideleg</code>)</a></h3>
<p>为提升中断和异常的处理性能，可以实现独立的可读写寄存器 <code>sedeleg</code> 和 <code>sideleg</code>，设置其中的位将特定的中断和异常交由用户态陷入处理程序处理。这两个寄存器与相应的机器态陷入委托寄存器 (<code>medeleg</code> 和 <code>mideleg</code>) 布局相同。只有已经被委托给 S 态的陷入对应的位才是可写的，其余位由硬件保持为 0 ，即只有委托给 S 态的陷入才可能被委托给 U 态。</p>
<p>当一个陷入被委托给一个权限较低的模式 u 时，<code>ucause</code> 寄存器被写入陷阱的原因；<code>uepc</code> 寄存器被写入发生陷阱的指令的虚拟地址；<code>utval</code> 寄存器被写入一个特定的异常数据；<code>mstatus</code> 的 UPIE 字段被写入陷阱发生时 UIE 字段的值；<code>mstatus</code> 的 UIE 字段被清零。<code>mcause</code>/<code>scause</code> 和 <code>mepc</code>/<code>sepc</code> 寄存器以及 <code>mstatus</code> 的 MPP 和 MPIE 字段不被写入。</p>
<p>一个实现不应硬性规定任何委托位为一，也就是说，任何可以被委托的陷阱都必须支持不被委托。一个实现方案是选择可委托的陷入的子集。支持的可委托位可通过向每个比特位置写 1，然后读回 <code>medeleg</code>/<code>sedeleg</code> 或 <code>mideleg</code>/<code>sideleg</code> 中的值，看看哪些位上有 1。</p>
<blockquote>
<p>目前，不支持触发低权限级的陷入</p>
</blockquote>
<p>不会在用户态发生的应硬件恒零，如 ECall from S/H/M-mode</p>
<h3 id="uscratch"><a class="header" href="#uscratch">uscratch</a></h3>
<p><code>uscratch</code> 寄存器是一个 UXLEN 位读/写寄存器。</p>
<h3 id="用户异常程序计数器-uepc"><a class="header" href="#用户异常程序计数器-uepc">用户异常程序计数器 (<code>uepc</code>)</a></h3>
<p><code>uepc</code> 是 UXLEN 位的可读写寄存器。最低位（<code>uepc[0]</code>）恒为零。次低位 <code>uepc[1]</code> 视实现的对齐需求而定。</p>
<p><code>uepc</code> 是 WARL 寄存器，必须能存储所有有效的虚拟地址，但不需要能够存储所有可能的无效地址。实现可以先将一些非法地址转为其他非法地址再写入 <code>uepc</code>。</p>
<p>当陷入在用户态处理时，被中断或触发异常的指令的虚拟地址被写入 <code>uepc</code>，除此之外 <code>uepc</code> 永远不会被硬件实现写入，但可能被软件显式写入。</p>
<h3 id="用户陷入原因寄存器-ucause"><a class="header" href="#用户陷入原因寄存器-ucause">用户陷入原因寄存器 (<code>ucause</code>)</a></h3>
<pre><code>| Interrupt | Exception Code (WLRL) |
</code></pre>
<p><code>ucause</code> 是 UXLEN 位长读写寄存器。当陷入在用户态处理时，触发陷入的事件编号被写入 <code>ucause</code>，除此之外 <code>ucause</code> 永远不会被硬件实现写入，但可能被软件显式写入。</p>
<table><thead><tr><th>Interrupt</th><th>Exception Code</th><th>Description</th></tr></thead><tbody>
<tr><td>1</td><td>0</td><td>用户态软件中断</td></tr>
<tr><td>1</td><td>1-3</td><td><em>预留</em></td></tr>
<tr><td>1</td><td>4</td><td>用户态时钟中断</td></tr>
<tr><td>1</td><td>5-7</td><td><em>预留</em></td></tr>
<tr><td>1</td><td>8</td><td>用户态外部中断</td></tr>
<tr><td>1</td><td>9-15</td><td><em>预留</em></td></tr>
<tr><td>1</td><td>≥16</td><td><em>由平台使用</em></td></tr>
<tr><td>0</td><td>0</td><td>指令地址未对齐</td></tr>
<tr><td>0</td><td>1</td><td>指令访问错误</td></tr>
<tr><td>0</td><td>2</td><td>非法指令</td></tr>
<tr><td>0</td><td>3</td><td>断点</td></tr>
<tr><td>0</td><td>4</td><td>加载地址未对齐</td></tr>
<tr><td>0</td><td>5</td><td>加载访问错误</td></tr>
<tr><td>0</td><td>6</td><td>存储/原子内存操作地址未对齐</td></tr>
<tr><td>0</td><td>7</td><td>存储/原子内存操作访问错误</td></tr>
<tr><td>0</td><td>8</td><td>用户态环境调用</td></tr>
<tr><td>0</td><td>9-11</td><td><em>预留</em></td></tr>
<tr><td>0</td><td>12</td><td>指令页错误</td></tr>
<tr><td>0</td><td>13</td><td>加载页错误</td></tr>
<tr><td>0</td><td>14</td><td><em>预留</em></td></tr>
<tr><td>0</td><td>15</td><td>存储/原子内存操作页错误</td></tr>
<tr><td>0</td><td>16-23</td><td><em>预留</em></td></tr>
<tr><td>0</td><td>24-31</td><td><em>自定义用途</em></td></tr>
<tr><td>0</td><td>32-47</td><td><em>预留</em></td></tr>
<tr><td>0</td><td>48-63</td><td><em>自定义用途</em></td></tr>
<tr><td>0</td><td>≥64</td><td><em>预留</em></td></tr>
</tbody></table>
<h3 id="用户陷入值寄存器-utval"><a class="header" href="#用户陷入值寄存器-utval">用户陷入值寄存器 (<code>utval</code>)</a></h3>
<p><code>utval</code> 是 UXLEN 位的可读写寄存器。当陷入在用户态处理时，和特定异常相关的信息将被写入 <code>utval</code> 以帮助软件处理陷入，除此之外 <code>utval</code> 永远不会被硬件实现写入，但可能被软件显式写入。硬件平台指定哪些异常必须将信息写入 <code>utval</code> ，以及哪些异常会无条件写入 0 。</p>
<p>当硬件断点被触发，或是一个指令/加载/存储地址未对齐/访问错误/页错误异常产生时，导致错误的虚拟地址被写入 <code>utval</code> 。当非法指令异常产生时，相应指令的前 XLEN 或 ILEN 位可能被写入 <code>utval</code> 。对于其他异常，<code>utval</code> 被置为 0 ，但未来的标准可能重新定义 <code>utval</code> 的设置。</p>
<h2 id="n-扩展的指令"><a class="header" href="#n-扩展的指令">N 扩展的指令</a></h2>
<h3 id="uret"><a class="header" href="#uret">URET</a></h3>
<p><code>uret</code> 将 <code>pc</code> 设置为 <code>uepc</code> ，将 <code>ustatus.UIE</code> 设置为 <code>ustatus.UPIE</code> ，从而恢复中断前的状态。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="用户态中断与异常的处理流程"><a class="header" href="#用户态中断与异常的处理流程">用户态中断与异常的处理流程</a></h1>
<p><img src="assets/user_trap_flow.drawio.svg" alt="用户态中断与异常的处理流程" /></p>
<h2 id="中断的产生"><a class="header" href="#中断的产生">中断的产生</a></h2>
<p>与 M 态和 S 态类似，中断分为软件中断 (Software Interrupt)、时钟中断 (Timer Interrupt) 和外部中断 (External Interrupt)。</p>
<blockquote>
<p>方便起见，三类中断会简称为 xSI、xTI、xEI，其中 x 为特权级。</p>
</blockquote>
<p>硬件或软件将 <code>uip.UXIP</code> (X 表示中断种类) 置为 1 ，硬件检测发现 <code>uip</code> 非零，进入中断的判断流程。</p>
<p>首先检查该中断是否被委托给用户态处理，即 <code>sideleg</code> 寄存器中对应的位是否为 1；如果为真，检查用户态全局中断使能是否为真，即 <code>ustatus.UIE</code> 是否为 1 ；若仍为真，再检查该中断是否被使能，即 <code>uie.UXIE</code> 是否为 1 ；如果还为真，则触发中断处理的流程。</p>
<blockquote>
<p><strong>注意</strong></p>
<p>上述寄存器中，<code>uie</code> <code>uip</code> 为 <code>mie</code> <code>mip</code> 的子集，即读写会同时作用于所有的 <code>xip</code> <code>xie</code> 或它们本就是同一寄存器。而 <code>ustatus</code> 至少 <code>UIE</code> 和 <code>UPIE</code> 与 <code>mstatus</code> 中的相同位相同。</p>
<p>虽然上述中断产生的流程中有判断次序，实际实现中一般使用组合逻辑，将寄存器值进行位与来判断，可以认为是同时判断的。</p>
</blockquote>
<h2 id="异常的产生"><a class="header" href="#异常的产生">异常的产生</a></h2>
<p>当异常发生时，硬件只检查 <code>sedeleg</code> 寄存器中对应的位是否为 1，若为真则触发异常的处理流程。</p>
<p>在 RISC-V 中，中断和异常的处理流程是统一的，下面出于描述简单考虑，多数情况下围绕中断进行描述。</p>
<h2 id="中断的处理"><a class="header" href="#中断的处理">中断的处理</a></h2>
<p>在上述的产生流程后，处理器开始进行一些预处理：</p>
<ul>
<li>设置 <code>ustatus.UPIE</code> 为 <code>ustatus.UIE</code> 的值，并置 <code>ustatus.UIE</code> 为 0</li>
<li>根据中断类型设置 <code>ucause</code></li>
<li>设置 <code>uepc</code> 为发生中断或异常时的 <code>pc</code></li>
<li>(可选) 设置 <code>utval</code></li>
<li>根据 <code>utvec</code> 的最低二位和高位的基地址，跳转到设置好的中断处理程序</li>
</ul>
<p>中断处理程序需要完成以下工作：</p>
<ul>
<li>保存现场</li>
<li>如果 <code>utvec</code> 为 direct 模式，根据 <code>ucause</code> 执行相应的处理程序</li>
<li>如果 <code>utvec</code> 为 vector 模式，执行处理程序</li>
<li>恢复现场</li>
</ul>
<p>中断处理程序通常需要保存和恢复的现场有：</p>
<ul>
<li>x1-x31 通用寄存器 (如果确定中断处理程序中不会使用到某些寄存器，可以省去保存和恢复)</li>
<li><code>ustatus</code> (可能需要通过修改 <code>ustatus</code> 来改变 CPU 状态)</li>
<li><code>uepc</code> (可能需要通过修改进一步触发 S 态的中断/异常)</li>
<li><strong>我们尚未注意到的但需要保存和恢复的寄存器</strong></li>
</ul>
<p><img src="assets/trap.drawio.svg" alt="中断与异常的硬件处理流程" /></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="外部中断与平台级中断控制器plic"><a class="header" href="#外部中断与平台级中断控制器plic">外部中断与平台级中断控制器（PLIC）</a></h1>
<h2 id="外部中断"><a class="header" href="#外部中断">外部中断</a></h2>
<p>外部中断主要用于处理与外设相关的中断，如 GPIO、UART、DMA 等。PLIC 接收所有外设的中断信号，根据程序配置的优先级、阈值和上下文规则，在相应的硬件线程上触发外部中断。程序需要从 PLIC 的 MMIO 寄存器中进一步读取具体的中断外设源信息。</p>
<p><code>mip.MEIP</code> 位对程序是只读的，只能由 PLIC 写入或清除。 <code>mip.SEIP</code> 可读写， M 态程序可以将该位置 1 ，而是否产生 S 态外部中断由该位的值和 PLIC 相应的信号逻辑或的结果决定，二者中任一为 1 即产生中断； <code>csrr</code> 、 <code>csrrs</code> 和 <code>csrrc</code> 指令在该位上的行为略有不同，具体可见规范。 <code>sip.SEIP</code> （对 S 态程序）是只读的。对于用户态中断的 <code>xip.UEIP</code> 位可以设计类似的约束条件。</p>
<h2 id="plic"><a class="header" href="#plic">PLIC</a></h2>
<p>目前的 <a href="https://github.com/riscv/riscv-plic-spec/blob/master/riscv-plic.adoc">PLIC 规范</a> 支持至多 1024 个（外设）中断源和 15872 套上下文，每个中断源至多可配置 2^32 种优先级，每套上下文至多可配置 2^32 种优先级阈值，以及在每套上下文中可配置每个中断源是否使能。</p>
<h3 id="中断触发条件"><a class="header" href="#中断触发条件">中断触发条件</a></h3>
<ol>
<li>中断源产生中断等待信号；</li>
<li>在某套上下文中，该中断源被使能；</li>
<li>该中断源的优先级高于该上下文的优先级阈值；</li>
</ol>
<p>上述条件均满足时，PLIC 会在硬件线程中触发外部中断，硬件线程编号与中断的特权级由上下文的设计决定。</p>
<h3 id="上下文"><a class="header" href="#上下文">上下文</a></h3>
<p>上下文指的是特定处理器中，特定硬件线程上的特定特权级，如果 CPU 中有三个硬件线程和两个可以处理中断的特权级（ M 和 S ），那么就存在六套 PLIC 上下文（在某个硬件线程上触发某个特权级的外部中断）。在该场景下，不妨按以下方法对上下文编号：</p>
<table><thead><tr><th></th><th>硬件线程 1</th><th>硬件线程 2</th><th>硬件线程 3</th></tr></thead><tbody>
<tr><td>运行在 M 态</td><td>上下文 1</td><td>上下文 3</td><td>上下文 5</td></tr>
<tr><td>运行在 S 态</td><td>上下文 2</td><td>上下文 4</td><td>上下文 6</td></tr>
</tbody></table>
<p>设某个中断源符合上下文 1 、2 和 6 的中断触发条件，那么 PLIC 会在硬件线程 1 上同时触发 MEI 和 SEI，在硬件线程 3 上触发 SEI ；在硬件线程 2 上，该中断源不会触发外部中断。</p>
<h3 id="中断领取与完成"><a class="header" href="#中断领取与完成">中断领取与完成</a></h3>
<p>PLIC 中每套上下文具有一个领取/完成（<code>claim/complete</code>）寄存器。程序读取该寄存器时，PLIC 会返回该上下文中优先级最高、等待信号有效且被使能的中断源编号（该中断源的优先级可以低于上下文阈值），清除该中断源的等待位，并全局屏蔽该中断源的中断有效信号。
程序向该寄存器中写入一个中断编号以通知 PLIC 该中断处理完成，若相应中断源在其上下文中被使能，则 PLIC 解除相应的屏蔽，否则忽略本次写入。</p>
<p>PLIC 对于领取/完成寄存器的读写是“无记忆”的，写入的中断编号与领取的编号可以不同。如果一个中断源在两个上下文中被使能，可以在第一个上下文领取该中断并屏蔽其信号，在第二个上下文中完成该中断并解除屏蔽。</p>
<h2 id="n-扩展下的-plic-设计"><a class="header" href="#n-扩展下的-plic-设计">N 扩展下的 PLIC 设计</a></h2>
<p>PLIC 的设计基本能够与 N 扩展兼容，只需为每个硬件线程的 U 态额外分配一套上下文，并将相应的中断信号与 <code>xip.UEIP</code> 位进行相应的连接逻辑即可。</p>
<p>每个上下文的领取/完成寄存器地址均与 4KB 边界对齐，故内核可以将 U 态对应上下文的地址直接映射到用户进程地址空间，这样用户进程可以直接完成领取/完成操作；中断源优先级和使能位对应的地址空间应当仅由内核访问和控制。</p>
<p>如何实现对外部中断的管理和复用，使其在多进程环境下仍然能够正常运行，见<a href="ch2_6_user_trap_management.html">用户态中断的管理</a>章节。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="硬件与模拟器"><a class="header" href="#硬件与模拟器">硬件与模拟器</a></h1>
<blockquote>
<p>本节介绍硬件与模拟器中实现的主要特性</p>
<p>可以在 <a href="ch1_n_ext_spec.html">N 扩展规范草案</a> 一节看到完整的 N 扩展及相关寄存器描述。在 <a href="ch1_use_of_user_mode_trap.html">用户态中断的使用</a> 一节中看到关于用户态中断使用的描述。</p>
</blockquote>
<h2 id="qemu-with-extension-n"><a class="header" href="#qemu-with-extension-n">QEMU with extension N</a></h2>
<p>出于稳定性考虑，我们选择以 <a href="https://github.com/qemu/qemu/tree/stable-5.0">QEMU 的 5.0 稳定分支</a> 为基础，添加用户态中断所需的寄存器和相应的中断处理函数。</p>
<p><img src="assets/qemu.png" alt="qemu" /></p>
<ul>
<li>添加寄存器 <code>ustatus</code> <code>uip</code> <code>uie</code> <code>sideleg</code> <code>sedeleg</code> <code>uepc</code> <code>utvec</code> <code>ucause</code> <code>utval</code> <code>uscratch</code></li>
<li>添加用户态中断的触发部分：符合条件时使上述处理器进入中断状态</li>
<li>实现 <code>uret</code> 指令</li>
<li>修改 PLIC 以支持用户态外部中断</li>
<li>添加串口用于测试</li>
</ul>
<p>一个使用修改后的 QEMU 进行的用户态中断的简单测试结果：</p>
<p><img src="assets/user_mode_trap_test.png" alt="user mode trap test" /></p>
<p>图中的 <code>user soft</code> 为用户态的中断处理程序接收到 <code>user soft interrupt</code> 后输出的信息，<code>user mode</code> 为用户态程序输出的信息。</p>
<h2 id="labeled-risc-v-n"><a class="header" href="#labeled-risc-v-n">Labeled RISC-V-N</a></h2>
<p>标签化 RISC-V 架构为中科院计算所包云岗老师团队的研究成果，通过给硬件资源请求附加标签，强化对系统中非托管共享资源（如 LLC、内存带宽等）的控制，降低资源争用时带来的性能波动。该系统使用的 CPU 核心为 Rocket Core，我们在此基础上添加了 N 扩展所需的寄存器、控制逻辑、指令和 PLIC 上下文，但并未使用和修改标签相关的部分；这些修改应当也可以平移到原版的 Rocket Core 中。</p>
<p>硬件平台使用赛灵思的 ZCU102 开发板，搭载 ZynqMP XCZU9EG 处理芯片。该芯片分为处理系统（PS）和可编程逻辑（PL）两部分，前者具有四个 Arm A53 核心，运行 Linux 系统，我们使用这一部分烧写比特流、将 RISC-V 部分的操作系统和启动器二进制文件加载到 DRAM 中、复位启动 RISC-V 核心。在后者上我们实例化了四个 Rocket Core，支持 RV64IMACN 指令集、MMU、CLINT 和 PLIC，时钟频率 100MHz，具有 2MB 共享 L2 缓存和 2GB DRAM。此外还加入了若干个串口用于与 RISC-V 部分交互以及用户态驱动的演示。</p>
<p>硬件系统架构图如下：</p>
<p><img src="assets/hardware.svg" alt="hardware" /></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="启动器与-sbi"><a class="header" href="#启动器与-sbi">启动器与 SBI</a></h1>
<p>我们基于 rustsbi 实现 QEMU 模拟器和 FPGA 上 OS 的启动与 sbi 层。</p>
<h2 id="rustsbi-qemu"><a class="header" href="#rustsbi-qemu">rustsbi-qemu</a></h2>
<p>我们基于 <code>rustsbi/rustsbi-qemu</code>，放开了对地址的保护，并添加了暂被 rustsbi 组织移除的多核支持以及中断委托。项目位于 <a href="https://github.com/duskmoon314/rustsbi-qemu/tree/legacy-multicore"><code>duskmoon314/rustsbi-qemu:legacy-multicore</code></a>。</p>
<h3 id="地址保护"><a class="header" href="#地址保护">地址保护</a></h3>
<p>在 RISC-V 中，有用于保护物理地址的寄存器 <code>pmpcfg</code> 和 <code>pmpaddr</code>。原本 rustsbi-qemu 只允许 sbi 部分和 OS 所在的地址空间可以使用，而并未允许 PLIC、串口等设备所在的物理地址。出于调试方便，我们放开了所有物理地址。</p>
<h3 id="中断委托"><a class="header" href="#中断委托">中断委托</a></h3>
<p>在修改后的 rustsbi-qemu 中，用户态的三种中断皆被 sbi 委托给 S 态的 OS，由 OS 决定如何处理。</p>
<h3 id="多核启动"><a class="header" href="#多核启动">多核启动</a></h3>
<p>最新版的 rustsbi-qemu 正在逐步支持 RISC-V sbi 标准的 hsm 扩展，因而移除了之前的多核启动方案。我们重新支持了多核启动，通过使用 <code>wfi</code> 指令，将核 0 以外的核卡在一个循环中，直到一个 M 态软件中断来让其余核跳出循环，进入 sbi 和 os 的设置与运行。</p>
<h2 id="lrv-rust-bl"><a class="header" href="#lrv-rust-bl">lrv-rust-bl</a></h2>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="内核对用户态中断的管理"><a class="header" href="#内核对用户态中断的管理">内核对用户态中断的管理</a></h1>
<h2 id="与其他特权级中断的比较"><a class="header" href="#与其他特权级中断的比较">与其他特权级中断的比较</a></h2>
<p>RISC-V 特权级指令架构规范中已经规定了机器态（M）和内核态（S）的中断规范，以及二者之间的互动机制，如特权级屏蔽、中断委托等。设计用户态（U）中断时，我们在一定程度上参照了现有的 S 态中断机制，并将 M 和 S 之间的关系平移到了 S 和 U 上，以保持整个中断架构的一致性。三种中断的完整处理流程图如下：</p>
<p><img src="assets/full_trap_flow.drawio.svg" alt="完整中断处理流程" /></p>
<p>在同时实现了 M 、S 和 U ，且没有实现 H 扩展的系统上，在 M 态运行的通常只有一个启动器（或者称为 SEE、SBI），且只在启动、发生 SBI 调用和处理部分中断时才执行代码；在 S 态运行的只有一个内核，一部分系统服务的代码可能在处理器上执行较长时间；这两个特权级只需要各自有一个陷入处理函数即可。</p>
<p>而在 U 态运行的通常有大量的用户程序，以时间片的方式轮流占用处理器执行。对于同步异常而言，这通常不构成问题，因为同步异常一定发生在某个程序执行自己的指令时触发；但对于异步中断，其来源往往无法知晓用户进程的状态，后者可能正在运行、处在调度队列中、进入睡眠甚至已经结束，如何确保进程收到自己想要的中断，同时不会错误地收到本应由其他进程处理的中断，就成了使用用户态中断时面临的核心问题。</p>
<h2 id="用户态中断上下文"><a class="header" href="#用户态中断上下文">用户态中断上下文</a></h2>
<p>为了解决上述问题，我们提出了“用户态中断上下文”的概念。用户态中断上下文包括各中断寄存器、外部中断映射和待处理中断记录。进程切换时，内核保存当前进程的用户态中断上下文，恢复下一进程的上下文，从而确保在多核、多进程环境下，进程的中断执行流仍然可以正常运行。</p>
<h3 id="中断记录"><a class="header" href="#中断记录">中断记录</a></h3>
<p>在 RISC-V 规范中，中断的原因存储于 xcause 寄存器中。但在多进程环境下，我们还需要对中断源进行区分，如发出信号的源进程、外部中断对应的外设编号等。我们在内核中加入了 UserTrapRecord 结构体实现这一目标：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
#[derive(Copy, Clone)]
pub struct UserTrapRecord {
    pub cause: usize,
    pub message: usize,
}
<span class="boring">}
</span></code></pre></pre>
<p>cause 中存储的内容基本与 xcause 寄存器保持一致，如对于 UTI 有 cause=4 ，对于 UEI cause=8 。对于 USI ，由于信号本身的值需要填入 message ，我们将源进程的 PID 编入 cause 中。标准的 xcause 编号为 0~15，只需 4 位，故我们令 cause=PID&lt;&lt;4 。</p>
<h3 id="中断缓冲区"><a class="header" href="#中断缓冲区">中断缓冲区</a></h3>
<p>当用户进程被调度离开硬件线程时，仍然有可能产生该进程需要处理的中断，此时由内核将中断记录暂存入该进程的中断缓冲区，待该进程再次被调度运行时进行处理。为了减少数据复制，我们将中断缓冲区设计为一个由进程和内核共享的完整的内存页，大小为 4KB ，在内核中仅记录该页的物理页号，而在用户地址空间中该页有固定的虚拟地址。内核还需要记录缓冲区中已有中断记录的数量，在返回用户进程时传递给用户态的中断处理程序。</p>
<p>理想情况下缓冲区应当实现为一个无锁的、多生产者、多消费者的环形队列，但现在为了简单起见，内核只根据 status.UIE 位来判断用户进程是否开启中断，如果为否，则不会写入新的中断记录。当用户进程进入中断处理程序时，硬件会自动将 ustatus.UIE 位清零，并从缓冲区中读取记录进行处理。</p>
<h3 id="外设中断使能"><a class="header" href="#外设中断使能">外设中断使能</a></h3>
<p>内核需要记录用户进程申请了哪些外设中断，以及相应设备在 PLIC 中是否启用，以便在进程调度切换时进行配置。</p>
<h2 id="进程切换流程"><a class="header" href="#进程切换流程">进程切换流程</a></h2>
<p>rCore-N 中进程切换基本流程为暂停当前进程——加入就绪队列——切换到调度器上下文——调度器选择下一个就绪进程——切换到该进程上下文——恢复运行。中断寄存器的保存和恢复以汇编形式加入任务上下文的切换代码中。即在任务切换时，<code>uie</code> <code>uip</code> <code>uepc</code> <code>utvec</code> <code>utval</code> <code>ucause</code> 六个寄存器也被存放到栈上，等待下一次被调度时用于恢复状态。</p>
<p>当进程被暂停时，对于其申请的每一个外设，在<strong>当前</strong>硬件线程的 U 态 PLIC 上下文中将其禁用；如果用户进程启用了该外设中断，则在<strong>当前</strong>硬件线程的 S 态 PLIC 上下文中启用，否则禁用。当进程恢复运行时，将外设在<strong>所有</strong>硬件线程的 S 态上下文中禁用，如果该外设中断被启用，则在<strong>当前</strong>硬件线程的 U 态上下文中启用，否则禁用。</p>
<p>进程退出时，内核在<strong>所有</strong>硬件线程的 U 态上下文中领取并完成该进程申请的每个外设的中断，将其在 U 态上下文中禁用，并在 S 态上下文中启用，从外设中断映射表中移除该外设。</p>
<p>当从内核态返回用户态（由于进程切换或系统调用）时，内核读取该进程的用户态中断上下文，若缓冲区不为空，则将缓冲区中的中断数量写入 <code>uscratch</code> 寄存器，同时置位 <code>sip.USIP</code> ，返回用户态。</p>
<p>PLIC 的上下文机制具体设计较为复杂，详见 <a href="ch2_3_external_interrupt_and_plic.html">外部中断与 PLIC</a> 一节。</p>
<p>进程切换的流程图如下：</p>
<p><img src="assets/proc_switch.svg" alt="proc_switch" /></p>
<h2 id="中断转发和注入"><a class="header" href="#中断转发和注入">中断转发和注入</a></h2>
<h3 id="软件中断与信号"><a class="header" href="#软件中断与信号">软件中断与信号</a></h3>
<p>RISC-V 规范中对于软件中断有如下描述：</p>
<blockquote>
<p>Interprocessor interrupts at supervisor level are implemented through implementation-specific mechanisms, e.g., via calls to an SEE, which might ultimately result in a machine-mode write to the receiving hart’s MSIP bit.
We allow a hart to directly write only its own SSIP bit, not those of other harts, as other harts might be virtualized and possibly descheduled by higher privilege levels. We rely on calls to the SEE to provide interprocessor interrupts for this reason. Machine-mode harts are not virtualized and can directly interrupt other harts by setting their MSIP bits, typically using uncached I/O writes to memory-mapped control registers depending on the platform specification.</p>
</blockquote>
<p>跨核软中断需要通过 SBI call ，由 SBI 经 CLINT 置位目标核上的 <code>mip.MSIP</code> 位，而程序只能写入本核的 <code>mip.SSIP</code> 位，因为 S 态程序可能运行在虚拟核上；出于同样的理由，我们应当限制程序只能写入本核的 <code>xip.USIP</code> 位。</p>
<p>用户进程可以通过 <code>send_msg()</code> 系统调用，向目标进程发送一条 <code>usize</code> 大小的信息，内核将该信息转为一条中断记录写入目标进程的中断缓冲区中。这样实现了类似信号的机制。</p>
<p>发送流程如下：</p>
<p><img src="assets/signal.svg" alt="signal" /></p>
<h3 id="时钟中断与虚拟定时器"><a class="header" href="#时钟中断与虚拟定时器">时钟中断与虚拟定时器</a></h3>
<p>在 RISC-V 特权级规范中，对于时钟中断有如下描述：</p>
<blockquote>
<p>A machine timer interrupt becomes pending whenever <code>mtime</code> contains a value greater than or equal to <code>mtimecmp</code>, treating the values as unsigned integers.
Lower privilege levels do not have their own <code>timecmp</code> registers. Instead, machine-mode software can implement any number of virtual timers on a hart by multiplexing the next timer interrupt into the <code>mtimecmp</code> register.</p>
</blockquote>
<p>硬件总是产生 M 态的时钟中断，当 M 态没有使用时钟中断的需求时，可以在 M 态的中断处理程序中无条件转发时钟中断到 S 态（置位 <code>mip.STIP</code> 并清除 <code>mie.MTIE</code> ）；在 S 态内核为每个硬件线程维护一个计时器队列，记录到期时刻和请求源（内核或某个进程），队列按照到期时刻由早到晚排序。</p>
<p>设置定时器时，将到期时间和进程 PID 写入队列中；对于内核设置的定时器，使用 0 号 PID （实际上在 rCore 中 0 号 PID 对应 initproc，但该进程不会设置定时器；或许更好的设计是使用 <code>usize::MAX</code> 指代内核）。若请求的时刻早于队列中已有的所有时刻，则（通过 SBI call ）将其写入 <code>mtimecmp</code> 。</p>
<p>内核接收到时钟中断时，将队首元素取出，判断定时器源，并更新 <code>mtimecmp</code>。若源为内核，则添加下一次调度中断，并暂停当前进程，进入调度器；若源为当前进程，则置位 <code>sip.UTIP</code> 并返回用户态（返回后将进入用户态中断处理函数）；若源为另一进程，则构造一条记录（message 内容为当前时间），放入目标进程的中断缓冲区中，并返回。</p>
<p>通过上述方法实现虚拟定时器后，可以更好地支持用户态线程调度器、<a href="https://www.usenix.org/conference/atc20/presentation/boucher">可抢占函数调用</a>等功能。</p>
<p>时钟中断的处理流程图如下：</p>
<p><img src="assets/uti.svg" alt="uti_flow" /></p>
<h3 id="外部中断与用户态驱动"><a class="header" href="#外部中断与用户态驱动">外部中断与用户态驱动</a></h3>
<p>由前述的进程切换流程，若某个进程正在某个硬件线程上运行，此时该进程所属的外设产生中断可以直接由 PLIC 转为 UEI 在用户态处理，而无需经过内核转发；若该进程未在运行，则 PLIC 会产生 SEI 进入内核，内核从 PLIC 领取外设编号（领取后 PLIC 会屏蔽该外设中断源信号，直至该中断被处理完成），判断应该由内核还是某个进程处理；若为后者，则向其缓冲区中写入一条中断记录并返回。用户进程的中断处理函数可以在自己的上下文中向 PLIC 提交中断完成信息，解除 PLIC 对该中断源的屏蔽。</p>
<p>外部中断处理流程图如下：</p>
<p><img src="assets/uei.svg" alt="uei" /></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="用户态中断扩展的使用"><a class="header" href="#用户态中断扩展的使用">用户态中断扩展的使用</a></h1>
<h2 id="系统调用"><a class="header" href="#系统调用">系统调用</a></h2>
<p>我们在 rCore-N 中添加了五个新的系统调用，供用户进程使用用户态中断机制。</p>
<h3 id="init_user_trap"><a class="header" href="#init_user_trap">init_user_trap()</a></h3>
<p>该系统调用用于通知内核为进程分配中断缓冲区内存页，并将 <code>sstatus.UIE</code> 置位。注意该调用不会设置 <code>xie.UXIE</code> ，用户进程应自行设置相应位以启用中断。若无法分配内存，或进程已经调用过该函数，则本次调用会失败并返回 -1 。</p>
<h3 id="send_msgpid-msg"><a class="header" href="#send_msgpid-msg">send_msg(pid, msg)</a></h3>
<p>该系统调用将向 pid 所指定的进程发送一条消息，若发送失败则返回 -1 。失败的可能原因有：目标进程未初始化中断缓冲区、缓冲区已满、目标进程全局关闭中断或相应进程不存在。
这一系统调用的作用类似于 Linux 中的 <code>signal()</code> ，但目前内核尚未对消息内容进行规范，如何解析和处理消息完全由源进程和目标进程决定。后续可能会加入对 Linux 信号编号的兼容支持，以及在内核中为一些信号提供额外的处理机制，如 SIGKILL 。</p>
<h3 id="set_timertime_us"><a class="header" href="#set_timertime_us">set_timer(time_us)</a></h3>
<p>为进程设置一个 time_us 后到期的定时器，到期后产生一个用户态时钟中断，或在相应进程的中断缓冲区中加入该信息。该调用类似于 <code>alarm()</code> ，其效果是一次性的。</p>
<h3 id="claim_ext_intdevice_id"><a class="header" href="#claim_ext_intdevice_id">claim_ext_int(device_id)</a></h3>
<p>将 device_id 对应的外设中断分配给调用进程，并将相应的 PLIC 领取/完成寄存器和外设地址映射到用户地址空间中（目前采用恒等映射）。调用成功时，返回相应外设的基址。
该调用可能的失败原因较多，包括当前进程未启用中断（-1），外设地址映射失败（-2），外设编号不合法（-4），中断缓冲区未初始化（-5），PLIC 领取/完成寄存器地址映射失败（-6）。</p>
<p>该调用不会在用户上下文中使能相应的外设，使能需要通过下一个系统调用来实现。将这两部分分开一方面是为了允许用户程序更精细地控制每个外设单独的使能情况，也是为了避免在用户完成外设初始化之前外设触发中断。</p>
<h3 id="set_ext_int_enabledevice_id-enable"><a class="header" href="#set_ext_int_enabledevice_id-enable">set_ext_int_enable(device_id, enable)</a></h3>
<p>在 PLIC 中启用或禁用对应外设在当前硬件线程的 U 态上下文的中断。enable &gt; 0 表示启用，否则为禁用。若启用，会同时在所有硬件线程的 S 态的上下文中禁用该中断。调用成功时返回 0 。若该外设被分配给其他进程则返回 -1 ，外设由内核管理时返回 -2 ，中断缓冲区未初始化时返回 -5 。</p>
<h2 id="用户态中断处理函数"><a class="header" href="#用户态中断处理函数">用户态中断处理函数</a></h2>
<p>用户进程可以读写 <code>utvec</code> 寄存器，令其指向自定义的中断处理函数入口。为了方便起见，我们在 rCore-N 的用户运行库中提供了一些缺省的实现，包括跳板代码、全局处理函数和三类中断各自的处理函数。</p>
<p>跳板代码使用汇编编写，将所有通用寄存器和一部分中断 CSR 的值保存在用户栈上，将上下文的地址写入 <code>a0</code> 寄存器，并跳转到全局处理函数。全局处理函数会根据 <code>ucause</code> 判断陷入类型，若为时钟中断，则直接调用相应的处理函数；若为外部中断，则从 PLIC 领取中断编号，传给外部中断处理函数，返回后向 PLIC 提交完成信息；若为软件中断，则从中断缓冲区中读取所有中断记录，并根据中断记录中的 <code>cause</code> 的值调用相应的处理函数。</p>
<p>全局处理函数和三类中断处理函数的签名如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[linkage = &quot;weak&quot;]
#[no_mangle]
pub fn user_trap_handler(cx: &amp;mut UserTrapContext) -&gt; &amp;mut UserTrapContext {...}

#[linkage = &quot;weak&quot;]
#[no_mangle]
pub fn ext_intr_handler(irq: u16, is_from_kernel: bool) {...}

#[linkage = &quot;weak&quot;]
#[no_mangle]
pub fn soft_intr_handler(pid: usize, msg: usize) {...}

#[linkage = &quot;weak&quot;]
#[no_mangle]
pub fn timer_intr_handler(time_us: usize) {...}
<span class="boring">}
</span></code></pre></pre>
<p>这些函数均使用弱链接标记，用户程序可以直接定义相同签名的函数，这样编译出的可执行文件中就会链接到用户的函数，而非缺省实现。注意使用 <code>#[no_mangle]</code> 标记以避免编译器对函数重命名。</p>
<h2 id="用户程序基本框架"><a class="header" href="#用户程序基本框架">用户程序基本框架</a></h2>
<pre><pre class="playground"><code class="language-rust">#[no_mangle]
pub fn main() -&gt; i32 {
    init_user_trap();
    claim_ext_int(device_id);
    set_ext_int_enable(device_id, 1);

    unsafe {
        uie::set_usoft();
        uie::set_utimer();
        uie::set_uext();
    }

    ...

    set_timer(time_us);
    send_msg(pid, msg);

    ...

    0
}

#[no_mangle]
pub fn ext_intr_handler(irq: u16, is_from_kernel: bool) {...}

#[no_mangle]
pub fn soft_intr_handler(pid: usize, msg: usize) {...}

#[no_mangle]
pub fn timer_intr_handler(time_us: usize) {...}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="rcore-n-的多核改造"><a class="header" href="#rcore-n-的多核改造">rCore-N 的多核改造</a></h1>
<p>在前文中，我们描述了用户态中断的机制和功能。然而基于单核环境的 rCore-Tutorial v3.5 改造的 rCore-N 并不能发挥出用户态中断的优势，所以我们需要对其进行多核改造。</p>
<h2 id="多核启动-1"><a class="header" href="#多核启动-1">多核启动</a></h2>
<h3 id="rustsbi-qemu-的多核启动"><a class="header" href="#rustsbi-qemu-的多核启动">rustsbi-qemu 的多核启动</a></h3>
<p>对于 SMP 架构，多核启动的一种简单方法是先启动核 0，在核 0 完成 OS 的启动后，通过某种方式“唤醒”其余的核。在 rustsbi-qemu 中，所有核在上电后都直接启动，执行到 <code>rust_main</code> 中的 <code>mp_hook</code> 函数。在 <code>mp_hook</code> 中，编号非 0 的核都会陷入循环，等待“M 态软件中断”来跳出循环，执行 sbi 层的初始化配置后跳转 OS。</p>
<h3 id="rcore-n-的多核启动"><a class="header" href="#rcore-n-的多核启动">rCore-N 的多核启动</a></h3>
<h4 id="启动栈"><a class="header" href="#启动栈">启动栈</a></h4>
<p>sbi 层完成配置后，首先进入一段汇编进行启动栈的配置，再跳转 rust 编写的内核初始化函数 <code>rust_main</code>。我们使用 4 核的 SMP 架构，每个核有 64KiB 的启动栈，即在 <code>.bss.stack</code> 段共有 256KiB 的空间用于 OS 的启动。此段根据核的 id，地址从低到高进行分配。</p>
<h4 id="初始化"><a class="header" href="#初始化">初始化</a></h4>
<p>OS 的初始化分为三个部分：核 0 进行整体的初始化、唤醒其他核、其他核自身的初始化。</p>
<p>整体初始化阶段，OS 需要初始化内存、PLIC 和共用的串口外设。在完成初始化后，核 0 通过调用 sbi 提供的接口，向另外三个核发送 IPI，通过 SBI 转为 M 态软件中断来唤醒它们。</p>
<p>其他核被唤醒后，进入相同的内核初始化函数，并根据其 id 进入核自身的初始化部分，设置自己的寄存器并配置对应自己的 PLIC 上下文。</p>
<p>简略的内核初始化函数如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn rust_main(hart_id: usize) -&gt; ! {
    if hart_id == 0 {
        // 全局初始化 核0初始化

        // 唤醒其他核
        for i in 1..CPU_NUM {
            let mask: usize = 1 &lt;&lt; i;
            send_ipi(&amp;mask as *const _ as usize);
        }
    } else {
        // 其他核初始化
    }
    // 开始运行
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="进程调度"><a class="header" href="#进程调度">进程调度</a></h2>
<h3 id="调度队列"><a class="header" href="#调度队列">调度队列</a></h3>
<p>出于实现和维护的简易性与简单使用场景的考虑，我们采用了单队列调度的方式。所有核共用一个“进程池”，其中只有一个进程调度队列；每个核有一个自己正持有并运行的进程。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TaskPool {
    pub scheduler: TaskManager, // 共享的调度队列
    ...
}

struct ProcessorInner {
    current: Option&lt;Arc&lt;TaskControlBlock&gt;&gt;, // 该核持有的进程
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>内核开始运行后，进入一个死循环，不断尝试从共享的调度队列中取出一个进程开始运行，如果没有取出则进入下一次循环。即多核不断抢同一个队列中的资源，进程可能频繁地在核之间轮转，因而会有亲和性的问题发生。但在进程数恰为核数时，进程几乎与核绑定，便可以避免不亲和的问题。</p>
<h3 id="死锁问题"><a class="header" href="#死锁问题">死锁问题</a></h3>
<p>在进程退出时，需要将属于自己的子进程交付不会退出的 0 号进程 <code>initproc</code> 来避免资源浪费。这要求同时持有进程自身和 <code>initproc</code> 的锁，在多核情境下会与 <code>waitpid</code> 等需要进程锁的函数发生冲突，甚至产生死锁。</p>
<p>目前 rCore-N 中采用一个名为 <code>WAIT_LOCK</code> 的大锁来解决此问题。所有需要获取多个进程锁的函数，都首先尝试获取这个锁，获取不到则自旋等待。以此方式来确保同一时间只有一处需要多个进程的锁，解决死锁问题。</p>
<h2 id="进程表"><a class="header" href="#进程表">进程表</a></h2>
<p>为支持通过 <code>pid</code> 寻找对应进程并进行进程间通信等操作，增加了一个 <code>&lt;pid, task&gt;</code> 的映射表。此表在进程创建时增加相应的项，在进程资源回收时先行尝试释放。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="使用教程"><a class="header" href="#使用教程">使用教程</a></h1>
<p>克隆仓库：</p>
<pre><code class="language-sh">git clone https://github.com/Gallium70/rv-n-ext-impl.git
cd rv-n-ext-impl
</code></pre>
<p>本仓库中包含多个子模组，不同的子模组之间并不一定能够组合出合理的搭配，故<strong>不建议</strong>直接使用 <code>git clone --recurse-submodules</code> 或是 <code>git clone --recurse-submodules</code> 一次性初始化所有的子模组，而是分别使用 <code>git submodule update --init xxx</code> 进行初始化。</p>
<h2 id="环境配置"><a class="header" href="#环境配置">环境配置</a></h2>
<p>主要开发环境为 Ubuntu 20.04 (WSL) ，其中一些使用 Rust 编写的项目在 Windows 下也可编译，Rust 环境配置可参考 <a href="https://rcore-os.github.io/rCore-Tutorial-Book-v3/chapter0/5setup-devel-env.html#rust">rCore-Tutorial</a>。
QEMU 的环境配置见 <a href="https://wiki.qemu.org/Hosts/Linux#Building_QEMU_for_Linux">Building QEMU for Linux</a>（我们推荐的编译路径和选项与此文中有所不同）；此外 QEMU 还提供了 <a href="https://wiki.qemu.org/Hosts/W32#Building_QEMU_for_W64">Windows 环境下的编译指南</a> ，但我们没有测试过。</p>
<h2 id="在-qemu-上运行-rcore-n"><a class="header" href="#在-qemu-上运行-rcore-n">在 QEMU 上运行 rCore-N</a></h2>
<h3 id="qemu"><a class="header" href="#qemu">QEMU</a></h3>
<pre><code class="language-sh">git submodule update --init qemu
cd qemu-build
../qemu/configure --target-list=&quot;riscv64-softmmu&quot;
make -j
</code></pre>
<p>我们选择在 qemu 文件夹之外（而非在其中创建子文件夹）进行编译是为了避免编译产生的大量中间文件被 git 追踪。
编译产生的可执行文件为 qemu-build/riscv64-softmmu/qemu-system-riscv64 。</p>
<p>调试 PLIC 可修改 <a href="../../qemu/hw/riscv/sifive_plic.c">sifive_plic.c</a> 中 <code>RISCV_DEBUG_PLIC</code> 宏的值为 1，然后在 qemu-build 目录中重新使用 <code>make -j</code> 编译。</p>
<h3 id="rcore-n"><a class="header" href="#rcore-n">rCore-N</a></h3>
<p>justfile 中默认将 QEMU 的三个串口映射到了 /dev/pts/24、/dev/pts/25 和 /dev/pts/31，可以在 Linux 中新打开两个终端，执行 <code>tty</code> 指令查看对应的设备路径，替换掉 justfile 中 -serial 后面的参数，并在新终端中执行 <a href="../../rCore-N/sleep.sh">sleep.sh</a> ，确保键盘输入传入了 QEMU 串口而非 shell 的 stdin/stdout 。</p>
<p>编译、运行：</p>
<pre><code class="language-sh">git submodule update --init rCore-N
cd rCore-N/os
just run
</code></pre>
<p>在 <code>just</code> 指令前设置 <code>LOG</code> 环境变量可以指定 rCore-N 的日志等级，如 <code>LOG=DEBUG just run</code> 会将日志等级设为 DEBUG 。</p>
<p>调试 rCore-N 可使用 <code>just debug</code> ，打开 QEMU 的调试输出使用 <code>just debug_qemu</code> 。</p>
<h2 id="在-fpga-上运行-rcore-n"><a class="header" href="#在-fpga-上运行-rcore-n">在 FPGA 上运行 rCore-N</a></h2>
<h3 id="fpga-环境配置"><a class="header" href="#fpga-环境配置">FPGA 环境配置</a></h3>
<pre><code class="language-sh">git submodule update --init labeled-RISC-V-N
cd labeled-RISC-V-N
</code></pre>
<p>后续步骤请参考<a href="../../labeled-RISC-V-N/fpga/README.html">子模组仓库中相应的教程</a>和<a href="https://github.com/Gallium70/labeled-RISC-V-reproduction-note">标签化 RISC-V 架构复现指南</a> 。</p>
<p>注意：该仓库初始化时会克隆 chisel 和 firrtl 的源代码并编译，编译时会克隆 riscv-linux（尽管本项目没有用到）和 verilator 源代码，FPGA 的综合和实现会消耗大量的 CPU 和内存资源，请保持耐心，并在开始前保存电脑上的所有工作，以防万一。</p>
<h3 id="lrv-rust-bl-1"><a class="header" href="#lrv-rust-bl-1">lrv-rust-bl</a></h3>
<pre><code class="language-sh">git submodule update --init lrv-rust-bl
cd lrv-rust-bl
just build
</code></pre>
<p>编译好的二进制文件位于 lrv-rust-bl/target/riscv64imac-unknown-none-elf/debug/lrv-rust-bl.bin</p>
<h3 id="rcore-n-1"><a class="header" href="#rcore-n-1">rCore-N</a></h3>
<p>修改 <a href="../../rCore-N/user/Makefile">user 文件夹中的 Makefile</a>，将第 14 行的 board_qemu 改为 board_lrv ，然后在 os 文件夹中执行 <code>just build_lrv</code> （或按需设置日志等级），编译好的二进制文件为 rCore-N/os/target/riscv64imac-unknown-none-elf/debug/os.bin 和 rcore-n.bin，二者内容完全一致。</p>
<h3 id="在-fpga-上运行"><a class="header" href="#在-fpga-上运行">在 FPGA 上运行</a></h3>
<p>将 lrv-rust-bl.bin 和 rcore-n.bin 复制到 FPGA 的 Arm Linux 中，使用<a href="https://github.com/Gallium70/labeled-RISC-V-boot">标签 RISC-V 启动脚本</a>启动 RISC-V 部分。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="系统测试与演示程序"><a class="header" href="#系统测试与演示程序">系统测试与演示程序</a></h1>
<h2 id="用户态中断测试"><a class="header" href="#用户态中断测试">用户态中断测试</a></h2>
<p>本项目中的 rv-csr-test 子模组是一个基本的 N 扩展寄存器行为测试程序，运行在 S 态，通过软件中断检查中断处理流程、中断委托和 <code>URET</code> 指令能否正常执行。程序需要 SBI 将 S 态和 U 态的中断委托给 S 态，默认入口点为 0x80200000 ，与 rCore-N 和 rustsbi-qemu 中的配置一致。</p>
<p>该程序首先在不开启委托的情况下将 <code>sip.SSIP</code> 和 <code>sip.USIP</code> 置位，检查能否正确进入中断处理函数，如果成功则会在终端输出 &quot;supervisor soft&quot; 和 &quot;user soft in supervisor&quot; ，验证了非委托情况下用户态中断会由更高特权级程序处理的设计。</p>
<p>随后会将软件中断委托给用户态，构造一个用户态执行上下文，并通过 <code>URET</code> 返回用户态。进入用户态后，将用户态中断处理函数入口写入 <code>utvec</code> ，将 <code>uie.USIE</code> 和 <code>uip.USIP</code> 置位，检查是否进入用户态中断处理函数，如果进入会在终端输出 &quot;user soft&quot; ，证明委托机制行为符合预期。</p>
<p>在该模组的 lrv-fpga 分支上，还有用于 FPGA 平台上、针对 PLIC 和 AXI UartLite 的测试，具体方法为初始化 PLIC 和串口，并启用串口中断，向串口写入大量数据，并读取串口状态。当串口发送缓冲区为空时会产生中断，此时检查能否从 PLIC 中领取和完成相应中断。</p>
<h2 id="用户态串口驱动库"><a class="header" href="#用户态串口驱动库">用户态串口驱动库</a></h2>
<p>我们将内核中使用的、基于中断的 16550 串口驱动（包括 QEMU 上模拟的串口和 FPGA 上使用的 AXI 16550）代码几乎原封不动复制到了用户运行库中，供用户程序使用。这样做一方面是为了简单，另一方面也是为了更好地验证用户态的外部中断能够正常运行。</p>
<h2 id="用户态中断演示程序"><a class="header" href="#用户态中断演示程序">用户态中断演示程序</a></h2>
<p>用户态中断演示程序运行在 rCore-N 中，主要包括两个程序：uart_ext 和 user_trap_demo 。前者为一个简单的串口回显终端，使用前述串口驱动库从串口读取用户输入，存入缓冲区中，并从终端输出；当用户输入回车时，会将缓冲区内容再次从终端输出，并清空缓冲区；当缓冲区中内容为 &quot;exit&quot; 时，程序退出。此外，该程序在进入外部中断处理函数以及收到消息时，会在内核终端中输出相应内容；收到的消息为 15 时（对应 SIGTERM 的编号），程序退出。</p>
<p>后者为时钟中断和信号的演示程序，程序启动时设置 10 个间隔一秒的定时器，并启动 uart_ext 进程；在时钟中断处理函数中，将 0xdeadbeef00 + t（t 为中断次数）作为消息内容发送给 uart_ext 进程；在最后一次中断时，向 uart_ext 发送 15，同时自己退出。</p>
<p>二者运行序列图如下：</p>
<p><img src="assets/demo_seq.svg" alt="demo_seq" /></p>
<p>在 QEMU 上运行的截图如下，其中调试信息串口 &quot;DEBUG&quot; 和 &quot;INFO&quot; 后的数字表示硬件线程编号：</p>
<p><img src="assets/demo_qemu.png" alt="demo_qemu" /></p>
<p>在 FPGA 上运行的截图如下，与前者内容基本相同：</p>
<p><img src="assets/demo_fpga.png" alt="demo_fpga" /></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="开发计划与重大进展"><a class="header" href="#开发计划与重大进展">开发计划与重大进展</a></h1>
<h2 id="计划"><a class="header" href="#计划">计划</a></h2>
<table><thead><tr><th>日期</th><th>计划</th></tr></thead><tbody>
<tr><td>7.5-7.11</td><td>查看 Rocket 的实现，确定中断的实际响应逻辑和 PLIC 的功能；在 rCore-N 中完成用户态中断实现的信号</td></tr>
<tr><td>7.12-7.18</td><td>分析 PLIC 的实现和如何工作，应如何操作 PLIC</td></tr>
<tr><td>7.19-7.25</td><td>在 rCore-N 中实现内核对用户态中断的管理机制，实现基本的演示程序</td></tr>
<tr><td>7.26-8.1</td><td>在 rCore-N 中实现用户态软件中断和时钟中断的应用，设计演示程序</td></tr>
<tr><td>8.2-8.8</td><td>在 FPGA 中实现相同功能，对 rCore-N 进行多核改造</td></tr>
<tr><td>8.9-8.15</td><td>继续完成 rCore-N 的多核改造，完善测试程序</td></tr>
<tr><td>8.16-8.18</td><td>完善测试程序和文档</td></tr>
</tbody></table>
<h2 id="进展"><a class="header" href="#进展">进展</a></h2>
<h3 id="2021-04-28"><a class="header" href="#2021-04-28">2021-04-28</a></h3>
<p>lvr-rust-bl 编写完成，成功在 FPGA 中运行 rustsbi 为依赖的 bootloader。</p>
<h3 id="2021-05-25"><a class="header" href="#2021-05-25">2021-05-25</a></h3>
<p>解决在 QEMU 模拟器中循环进入用户态中断的问题，触发用户态软件中断可以正常进入和退出中断处理程序。</p>
<h3 id="2021-07-11"><a class="header" href="#2021-07-11">2021-07-11</a></h3>
<p>修改 rustsbi-qemu，放通增加的串口与 PLIC 所在地址。</p>
<h3 id="2021-07-12"><a class="header" href="#2021-07-12">2021-07-12</a></h3>
<p>讨论决定参考 <a href="https://github.com/sgmarz/osblog"><code>sgmarz/osblog</code></a> 使用 PLIC。</p>
<p>开始分析 QEMU 和 FPGA 中 PLIC 的实现方式，确定 PLIC 的大致使用方式。</p>
<h3 id="2021-07-18"><a class="header" href="#2021-07-18">2021-07-18</a></h3>
<p>将操作 PLIC 的基本 rust 代码整理，拆为 <code>rv-plic</code> crate 以方便后期复用。</p>
<p>在 QEMU 中增加 PLIC 的用户态上下文，并在 rCore-N 中增加相应驱动。</p>
<p>在 rCore-N 中添加内核对用户态中断上下文的保存与恢复机制、用户态中断的默认处理函数，增加向内核注册中断的系统调用。</p>
<h3 id="2021-07-22"><a class="header" href="#2021-07-22">2021-07-22</a></h3>
<p>将操作串口的基本 rust 代码整理，拆为 <code>uart-rs</code> 项目，方便内核和用户态的复用。</p>
<h3 id="2021-07-25"><a class="header" href="#2021-07-25">2021-07-25</a></h3>
<p>在 QEMU 模拟器中增加串口，并将一个串口完全交由用户态进程控制，接收 PLIC 传入的用户态外部中断，并将数据再输回串口。</p>
<h3 id="2021-07-27"><a class="header" href="#2021-07-27">2021-07-27</a></h3>
<p>用户态三种中断皆可用，内核使用中断来向用户态进程传递 IPC 信号。并且初步实现一个用户态进程向另一个控制串口的用户态进程发送信息并显示的示例程序。</p>
<h3 id="2021-08-03"><a class="header" href="#2021-08-03">2021-08-03</a></h3>
<p>成功启动多核，但由于任务队列实现有误无法正常实现。</p>
<h3 id="2021-08-04"><a class="header" href="#2021-08-04">2021-08-04</a></h3>
<p>在 verilator 模拟器中成功运行增加了 N 扩展支持的 FPGA 实现。发现模拟器会给寄存器赋随机初值，尝试修改相关初始化代码。</p>
<h3 id="2021-08-11"><a class="header" href="#2021-08-11">2021-08-11</a></h3>
<p>在 QEMU 模拟器中基本完成 rCore-N 的多核改造，开始往 FPGA 上移植。初步完成 FPGA 中串口的用户态驱动。</p>
<h3 id="2021-08-14"><a class="header" href="#2021-08-14">2021-08-14</a></h3>
<p>增加 <code>(pid, task)</code> 的映射表，并修改 <code>find_task</code> 的实现。</p>
<p>FPGA 中串口有 Uart Lite 换为 16550 以解决速率慢的问题。</p>
<p>解决多核的死锁问题，成功运行并退出编写的 <code>uart_ext</code> 示例程序。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="遇到的主要问题与解决方法"><a class="header" href="#遇到的主要问题与解决方法">遇到的主要问题与解决方法</a></h1>
<h2 id="寄存器和-bss-段初始化"><a class="header" href="#寄存器和-bss-段初始化">寄存器和 BSS 段初始化</a></h2>
<p>使用 verilator 仿真 FPGA 代码时，发现 lrv-rust-bl 启动器无任何输出。打开仿真调试输出会在日志文件中输出每一条指令的执行结果和影响的寄存器值，日志行数轻松达到数十万甚至上百万之多。
于是在代码中插入 <code>ebreak</code> 、<code>nop</code> 、<code>csrr zero, xxx</code> 等正常情况下不会出现的指令，结合反汇编定位问题代码，并探查 CSR 内的数值。</p>
<p>结果发现，仿真时内存和寄存器均为随机初始化，CSR 中甚至可能出现非法值——如 <code>mideleg</code> 寄存器中 M 态中断对应的位为 1 ，意味着将 M 态中断委托到了 S 态处理，这是规范所不允许的；CPU 会在写入和读取该寄存器时做检查，但并不会处理随机初始化的情况。于是在启动代码中，将所有通用寄存器清零，CSR 写入一个合法的值。</p>
<p>另一方面，代码中使用的未初始化的全局变量位于 bss 和 sbss 段中，但程序链接脚本中缺少了 sbss 段，没有在程序启动阶段正常清零，导致一些全局变量初始化失败。在链接脚本中加入 sbss 段解决了这一问题。</p>
<h2 id="中断处理函数中的死锁问题"><a class="header" href="#中断处理函数中的死锁问题">中断处理函数中的死锁问题</a></h2>
<p>编写串口驱动时，将串口对象包装在 <code>Mutex</code> 结构中，以确保任何时候只有一段执行流能够访问串口。但在单线程情况下，当主程序获取锁之后，串口仍然可能产生中断而进入中断处理程序，中断处理函数会再次尝试获取串口锁而进入等待；中断处理函数不返回时主程序不会继续执行，因而无法释放锁，导致出现死锁。</p>
<p>解决方案主要有四个，一是在主程序获取锁之前关闭中断，释放锁后再打开；二是将串口对象所有权保持在主程序中，中断处理程序通过一个静态原子变量通知主程序有中断产生，并禁用中断，主程序读取该变量，发现有中断时再调用串口的中断处理函数，并重新打开中断；
三是想办法将串口对象改造为无锁的，如主程序仅访问一个 <code>heapless::spsc</code> 的无锁队列，中断处理程序负责访问串口硬件；四是将中断处理函数移到单独的线程中执行。</p>
<p>rCore-N 中目前还没有多线程支持，故四不可行；三在主程序试图通过串口输出时可能有问题，因为单纯将数据写入软件缓冲区不能无法发起串口传输；一和二可行度较高，目前主要采用的是方案一。</p>
<h2 id="多核改造中的死锁问题"><a class="header" href="#多核改造中的死锁问题">多核改造中的死锁问题</a></h2>
<p>在 rCore-N 的改造中，遇到了一个死锁问题：</p>
<p>进程 1 在退出时，内核获取 1 的锁来访问它的信息，同时要获取 0 号进程的锁，将进程 1 的子进程放到 0 号进程的子进程列表中，以避免资源不能正确地释放。同时，0 号进程会调用 <code>wait_pid</code> 系统调用，查看自己的子进程是否有运行结束的，来释放资源。而在 <code>wait_pid</code> 中，会需要获取调用者（0 号进程）与目标进程的锁，来访问它们的信息。</p>
<p>在单核环境下，由于上述两种过程都发生于内核态，且不允许嵌套中断，便不会发生死锁问题。而在多核环境下，0 号进程运行在一个核上，调用 <code>wait_pid</code> 去查看子进程 1 号；1 号进程运行在另一个核上，正在退出。这时就很有可能分别持有 0 号和 1 号的锁，要拿另一方的锁来查看或更改信息，从而进入死锁状态。</p>
<p>我们采用加一个大锁的方式来解决此问题，即当一段程序需要获取多个进程的锁时，需要先尝试获取大锁。在获取了大锁之后才会进入获取多个进程的锁的程序，避免了上述多段程序同时需要获取多个进程的锁的问题。</p>
<p>具体到代码上，简略后如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn sys_waitpid(pid: isize, exit_code_ptr: *mut i32) -&gt; isize {
    // 获取大锁
    let _ = WAIT_LOCK.lock();
    // 获取当前进程的锁
    ...
    // 遍历子进程，获取锁来读取状态
    ...
}

pub fn exit_current_and_run_next(exit_code: i32) {
    // 获取大锁
    let wl = WAIT_LOCK.lock();
    // 获取要退出进程的锁
    ...
    // 获取 0 号进程的锁
    ...
    // 释放所有锁
    drop(wl);
    ...
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="多核切换带来的-plic-上下文变动问题"><a class="header" href="#多核切换带来的-plic-上下文变动问题">多核切换带来的 PLIC 上下文变动问题</a></h2>
<p>在处理用户态外部中断时，有如下两种写法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>while let Some(irq) = Plic::claim(get_context(hart_id(), 'U')) {
    ext_intr_handler(irq, false);
    Plic::complete(get_context(hart_id(), 'U'), irq);
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
    let context = get_context(hart_id(), 'U');
    if let Some(irq) = Plic::claim(context) {
        ext_intr_handler(irq, false);
        Plic::complete(get_context(context, 'U'), irq);
    } else {
        break;
    }
}

<span class="boring">}
</span></code></pre></pre>
<p>主要区别在于，前者在 PLIC 领取和完成中断时，都会调用 <code>hart_id()</code> 和 <code>get_context()</code> 获取 PLIC 上下文编号，而后者将一次 <code>get_context</code> 的结果存入临时变量中，使用两次。乍看之下两种写法似乎等价，后者还能够节省两个函数调用；但实际上只有第一种写法能够正常运行。</p>
<p>问题的一方面在于，用户态的中断处理函数仍然可能被内核时钟中断而进入调度器；而相应的，进入内核中断处理函数时会关闭内核中断，此时不会响应时钟中断。这是很合理的：用户态的中断处理函数不应该能够突破基于时间片的多进程切换机制。这意味着 PLIC 领取和完成的代码可能在不同的硬件线程上执行。</p>
<p>问题的另一方面与 PLIC 的上下文设计以及内核在切换进程时的 PLIC 配置有关。假设进程领取了 A 外设的中断，硬件线程 1 的用户态对应的上下文编号为 3 ，硬件线程 2 的用户态对应的上下文编号为 6 （这里仅为方便举例，并不符合实际的上下文编号规则）。
当进程在硬件线程 1 上领取到 A 外设中断并离开时，内核会在 3 号上下文禁用 A 外设的中断使能，以避免随后在 1 上运行的进程被 A 外设中断；当进程被调度到硬件线程 2 上运行时，内核会在 6 号上下文中启用 A 外设中断。</p>
<p>PLIC 并不要求领取和完成在同一上下文中，但是只有中断在相应上下文中被使能时，领取和完成才是有效的。如果进程在硬件线程 2 上运行时，仍然向 PLIC 提交 3 号上下文的完成请求，由于此上下文中 A 外设没有被使能，故此次完成无效，A 外设的中断会保持屏蔽状态，进程便再也无法收到该中断。相反，进程向 PLIC 提交 6 号上下文的完成请求是有效的，A 外设中断屏蔽被解除，程序能够继续正常运行。</p>
<p>因此，用户程序提交完成请求时，应始终使用当前上下文提交；或者在所有上下文中都提交一遍。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="分工协作"><a class="header" href="#分工协作">分工协作</a></h1>
<p>贺鲲鹏：</p>
<ul>
<li>扩展规范草案</li>
<li>用户态中断处理流程</li>
<li>QEMU 修改</li>
<li>rCore-N 多核改造</li>
<li>PLIC 和串口底层驱动</li>
</ul>
<p>尤予阳：</p>
<ul>
<li>FPGA 修改</li>
<li>FPGA 启动器编写</li>
<li>rCore-N 移植</li>
<li>内核对用户态中断管理机制</li>
<li>演示程序</li>
<li>使用教程编写</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
