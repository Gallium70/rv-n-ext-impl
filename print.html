<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Risc-V Extension N Implementation</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> 简介</a></li><li class="chapter-item expanded "><a href="ch1_0_background.html"><strong aria-hidden="true">2.</strong> 项目背景</a></li><li class="chapter-item expanded "><a href="ch2_0_design.html"><strong aria-hidden="true">3.</strong> 系统设计</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch2_1_n_ext_spec.html"><strong aria-hidden="true">3.1.</strong> N 扩展规范草案</a></li><li class="chapter-item expanded "><a href="ch2_2_user_trap_handle_flow.html"><strong aria-hidden="true">3.2.</strong> 用户态中断的处理流程</a></li><li class="chapter-item expanded "><a href="ch2_3_external_interrupt_and_plic.html"><strong aria-hidden="true">3.3.</strong> 外部中断与 PLIC</a></li><li class="chapter-item expanded "><a href="ch2_4_n_ext_on_qemu_and_fpga.html"><strong aria-hidden="true">3.4.</strong> QEMU 和 FPGA 中的 N 扩展支持</a></li><li class="chapter-item expanded "><a href="ch2_5_bootloader.html"><strong aria-hidden="true">3.5.</strong> 启动器与 SBI</a></li><li class="chapter-item expanded "><a href="ch2_6_user_trap_management.html"><strong aria-hidden="true">3.6.</strong> 内核对用户态中断的管理</a></li><li class="chapter-item expanded "><a href="ch2_7_user_trap_usage.html"><strong aria-hidden="true">3.7.</strong> 用户态中断的使用方案</a></li><li class="chapter-item expanded "><a href="ch2_8_rcore_n_smp.html"><strong aria-hidden="true">3.8.</strong> rCore-N 的多核改造</a></li></ol></li><li class="chapter-item expanded "><a href="ch3_0_user_guide.html"><strong aria-hidden="true">4.</strong> 使用方法</a></li><li class="chapter-item expanded "><a href="ch4_0_test_and_demo.html"><strong aria-hidden="true">5.</strong> 系统测试与演示程序</a></li><li class="chapter-item expanded "><a href="ch5_0_plan_and_progress.html"><strong aria-hidden="true">6.</strong> 开发计划与进展</a></li><li class="chapter-item expanded "><a href="ch6_0_problem_and_solutions.html"><strong aria-hidden="true">7.</strong> 遇到的主要问题和解决方法</a></li><li class="chapter-item expanded "><a href="ch7_0_cooperation.html"><strong aria-hidden="true">8.</strong> 分工与协作</a></li><li class="chapter-item expanded "><a href="ch8_0_repo_structure.html"><strong aria-hidden="true">9.</strong> 提交仓库目录和文件描述</a></li><li class="chapter-item expanded "><a href="ch9_0_summary.html"><strong aria-hidden="true">10.</strong> 比赛收获</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Risc-V Extension N Implementation</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="软硬协同的用户态中断"><a class="header" href="#软硬协同的用户态中断">软硬协同的用户态中断</a></h1>
<p>注：<strong>该文档正在修订中，内容可能发生大幅变化</strong></p>
<h2 id="目标"><a class="header" href="#目标">目标</a></h2>
<p>本项目在现有 <a href="https://five-embeddev.com/riscv-isa-manual/latest/n.html">RISC-V 用户态中断扩展规范草案</a> 的基础上将其进一步完善，提出一种符合该规范的模拟器和 FPGA 实现，并基于用户态中断在内核中实现优化的信号和 io_uring 等跨进程通信机制，展示其设计和性能优势。</p>
<h2 id="项目设计"><a class="header" href="#项目设计">项目设计</a></h2>
<p>项目架构设计如下：</p>
<p><img src="assets/proj.svg" alt="arch" /></p>
<ul>
<li>模拟器：修改 QEMU 5.0，在其中添加 N 扩展支持</li>
<li>FPGA：基于中科院计算所的<a href="https://github.com/LvNA-system/labeled-RISC-V/tree/master/fpga">标签化 RISC-V 架构</a>，添加 N 扩展支持</li>
<li>启动器与 SBI：在 FPGA 平台上使用基于 RustSBI 开发的 <a href="https://github.com/Gallium70/lrv-rust-bl">lrv-rust-bl</a> ，在 QEMU 上 uCore-SMP 系统使用 OpenSBI ，rCore 系统使用 RustSBI</li>
<li>操作系统：选择 <a href="https://github.com/TianhuaTao/uCore-SMP">uCore-SMP</a> 和 <a href="https://github.com/duskmoon314/rCore-N">rCore-N</a></li>
</ul>
<h3 id="文件结构"><a class="header" href="#文件结构">文件结构</a></h3>
<pre><code>.
├── README.md
├── docs                docs in mdbook structure
├── Labeled-uCore-SMP   uCore SMP with labeled RISC-V support
├── lrv-rust-bl         Labeled RISC-V fpga bootloader based on RustSBI
├── qemu                qemu modified by Campbell He
├── qemu-build          folder holding qemu build artifacts
├── rCore-N             rCore with N extension
└── rv-csr-test         N extension simple test program
</code></pre>
<h2 id="开发进展"><a class="header" href="#开发进展">开发进展</a></h2>
<h3 id="qemu-与-fpga"><a class="header" href="#qemu-与-fpga">QEMU 与 FPGA</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
在 QEMU 中添加 N 扩展支持</li>
<li><input disabled="" type="checkbox" checked=""/>
在 FPGA 开发板上部署标签化 RISC-V 架构</li>
<li><input disabled="" type="checkbox"/>
增加 N 扩展的 Chisel 代码</li>
</ul>
<h3 id="操作系统"><a class="header" href="#操作系统">操作系统</a></h3>
<ul>
<li>rCore
<ul>
<li><input disabled="" type="checkbox" checked=""/>
添加 N 扩展支持</li>
<li><input disabled="" type="checkbox"/>
适配 FPGA 平台</li>
<li><input disabled="" type="checkbox"/>
适配标签机制</li>
<li><input disabled="" type="checkbox"/>
多核支持</li>
<li><input disabled="" type="checkbox" checked=""/>
实现信号机制</li>
<li><input disabled="" type="checkbox"/>
实现 io_uring</li>
</ul>
</li>
<li>uCore-SMP
<ul>
<li><input disabled="" type="checkbox"/>
添加 N 扩展支持</li>
<li><input disabled="" type="checkbox" checked=""/>
适配 FPGA 平台</li>
<li><input disabled="" type="checkbox" checked=""/>
适配标签机制</li>
<li><input disabled="" type="checkbox"/>
实现信号机制</li>
<li><input disabled="" type="checkbox"/>
实现 io_uring</li>
</ul>
</li>
</ul>
<h3 id="应用程序"><a class="header" href="#应用程序">应用程序</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
验证 N 扩展正常工作</li>
<li><input disabled="" type="checkbox" checked=""/>
信号机制测例</li>
<li><input disabled="" type="checkbox"/>
io_uring 测例</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="项目背景"><a class="header" href="#项目背景">项目背景</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="设计"><a class="header" href="#设计">设计</a></h1>
<p>本章将介绍我们对于本项目的设计思路，即我们“为什么”要这么做。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="n-扩展规范草案----omit-in-toc---"><a class="header" href="#n-扩展规范草案----omit-in-toc---">N 扩展规范草案 <!-- omit in toc --></a></h1>
<blockquote>
<p>目前此扩展适用于实现了 M/S/U 三种特权级和 CLINT+PLIC 的系统，暂不考虑与 H 扩展以及 AIA、CLIC、ACLINT 等中断机制的兼容或适配。</p>
</blockquote>
<ul>
<li><a href="ch2_1_n_ext_spec.html#n-%E6%89%A9%E5%B1%95%E7%9A%84-csr">N 扩展的 CSR</a>
<ul>
<li><a href="ch2_1_n_ext_spec.html#%E7%94%A8%E6%88%B7%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8-ustatus">用户状态寄存器 (<code>ustatus</code>)</a></li>
<li><a href="ch2_1_n_ext_spec.html#%E7%94%A8%E6%88%B7%E9%99%B7%E5%85%A5%E5%90%91%E9%87%8F%E5%9F%BA%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8-utvec">用户陷入向量基址寄存器 (<code>utvec</code>)</a></li>
<li><a href="ch2_1_n_ext_spec.html#%E7%94%A8%E6%88%B7%E4%B8%AD%E6%96%AD%E5%AF%84%E5%AD%98%E5%99%A8-uip-%E4%B8%8E-uie">用户中断寄存器 (<code>uip</code> 与 <code>uie</code>)</a></li>
<li><a href="ch2_1_n_ext_spec.html#%E5%86%85%E6%A0%B8%E6%80%81%E9%99%B7%E5%85%A5%E5%A7%94%E6%89%98%E5%AF%84%E5%AD%98%E5%99%A8-sedeleg-%E4%B8%8E-sideleg">内核态陷入委托寄存器 (<code>sedeleg</code> 与 <code>sideleg</code>)</a></li>
<li><a href="ch2_1_n_ext_spec.html#uscratch">uscratch</a></li>
<li><a href="ch2_1_n_ext_spec.html#%E7%94%A8%E6%88%B7%E5%BC%82%E5%B8%B8%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8-uepc">用户异常程序计数器 (<code>uepc</code>)</a></li>
<li><a href="ch2_1_n_ext_spec.html#%E7%94%A8%E6%88%B7%E9%99%B7%E5%85%A5%E5%8E%9F%E5%9B%A0%E5%AF%84%E5%AD%98%E5%99%A8-ucause">用户陷入原因寄存器 (<code>ucause</code>)</a></li>
<li><a href="ch2_1_n_ext_spec.html#%E7%94%A8%E6%88%B7%E9%99%B7%E5%85%A5%E5%80%BC%E5%AF%84%E5%AD%98%E5%99%A8-utval">用户陷入值寄存器 (<code>utval</code>)</a></li>
</ul>
</li>
<li><a href="ch2_1_n_ext_spec.html#n-%E6%89%A9%E5%B1%95%E7%9A%84%E6%8C%87%E4%BB%A4">N 扩展的指令</a>
<ul>
<li><a href="ch2_1_n_ext_spec.html#uret">URET</a></li>
</ul>
</li>
</ul>
<h2 id="n-扩展的-csr"><a class="header" href="#n-扩展的-csr">N 扩展的 CSR</a></h2>
<h3 id="用户状态寄存器-ustatus"><a class="header" href="#用户状态寄存器-ustatus">用户状态寄存器 (<code>ustatus</code>)</a></h3>
<pre><code>UXLEN-1 5   4    3  1    0
┌────────┬──────┬──────┬─────┐
│  WPRI  │ UPIE │ WPRI │ UIE │
└────────┴──────┴──────┴─────┘
  UXLEN-5   1       3     1
</code></pre>
<p><code>ustatus</code> 是一个 UXLEN 位长的可读写寄存器，记录和控制硬件线程当前的工作状态。</p>
<p>用户态中断使能位 UIE 为零时，用户态中断被禁用。为了向用户态陷入处理程序提供原子性，UIE 中的值在用户态中断发生时被复制到 UPIE ，且 UIE 被置为零。</p>
<p>UIE 和 UPIE 是 <code>mstatus</code> 和 <code>sstatus</code> 中对应位的镜像。</p>
<blockquote>
<p>进入用户态中断处理函数之前的特权级只可能是用户态，所以不需要 UPP 位。</p>
</blockquote>
<p>指令 URET 用于从用户态陷入状态中返回。URET 将 UPIE 复制回 UIE，然后将 UPIE 置位，最后将 <code>uepc</code> 拷贝至 <code>pc</code>。</p>
<blockquote>
<p>在 UPIE/UIE 栈弹出后置位 UPIE 是为了启用中断，以及帮助发现代码中的错误。</p>
</blockquote>
<h3 id="用户陷入向量基址寄存器-utvec"><a class="header" href="#用户陷入向量基址寄存器-utvec">用户陷入向量基址寄存器 (<code>utvec</code>)</a></h3>
<pre><code>| BASE[UXLEN-1 : 2] | MODE |
</code></pre>
<p><code>utvec</code> 是 UXLEN 位长的可读写寄存器，存储陷入向量的设置，包括向量基址 (BASE) 和向量模式。</p>
<p><code>utvec</code> 中的 BASE 为 <strong>WARL</strong> 字段，可以存储任何有效的虚拟地址或物理地址，地址需要对齐到 4 字节。其他的向量模式可能有额外的对齐约束条件。</p>
<table><thead><tr><th>value</th><th>name</th><th>description</th></tr></thead><tbody>
<tr><td>0</td><td>direct</td><td>base</td></tr>
<tr><td>1</td><td>vectored</td><td>base + 4 * cause</td></tr>
<tr><td></td><td></td><td>reserved</td></tr>
</tbody></table>
<h3 id="用户中断寄存器-uip-与-uie"><a class="header" href="#用户中断寄存器-uip-与-uie">用户中断寄存器 (<code>uip</code> 与 <code>uie</code>)</a></h3>
<p><code>uip</code> 和 <code>uie</code> 均为 UXLEN 位的可读写寄存器，其中 <code>uip</code> 存储等待处理的中断信息， <code>uie</code> 存储相应的中断使能位。</p>
<pre><code>UXLEN-1  9    8   7    5    4   3    1    0
| WPRI    | UEIP | WPRI | UTIP | WPRI | USIP |

| WPRI    | UEIE | WPRI | UTIE | WPRI | USIE |
  UXLEN-9     1      3      1      3      1
</code></pre>
<p>定义三种中断：软件中断、时钟中断和外部中断。用户态软件中断通过置位当前硬件线程的 <code>uip</code> 的软件中断等待位 (USIP) 来触发。清零该位可以清除待处理的软件中断。当 <code>uie</code> 中的 USIE 为零时，用户态软件中断被禁用。</p>
<p>ABI 应当提供一种向其他硬件线程发送跨核中断的机制，这最终将置位接收方硬件线程 <code>uip</code> 寄存器的 USIP 位。</p>
<p>除了 USIP， <code>uip</code> 中的其他位在用户态是只读的。</p>
<p>如果 <code>uip</code> 寄存器中的 UTIP 位被置位，将产生一个待处理的用户态时钟中断。当 <code>uie</code> 寄存器中的 UTIE 位被置零时，用户态时钟中断被禁用。ABI 应该提供清除待处理的时钟中断的机制。</p>
<p>如果 <code>uip</code> 寄存器中的 UEIP 位被置位，将产生一个待处理的用户态外部中断。当 <code>uie</code> 寄存器中的 UEIE 位被置位时，用户态外部中断被禁用。ABI 应该提供屏蔽、解除屏蔽和查询外部中断原因的机制。</p>
<p><code>uip</code> 和 <code>uie</code> 寄存器是 <code>mip</code> 和 <code>mie</code> 寄存器的子集。对 <code>uip</code>/<code>uie</code> 任何字段的读取或写入操作，都会等效为对 <code>mip</code>/<code>mie</code> 的相应字段的读取或写入。如果系统实现了 S 模式，<code>uip</code> 和 <code>uie</code> 寄存器也是 <code>sip</code> 和 <code>sie</code> 寄存器的子集。</p>
<h3 id="内核态陷入委托寄存器-sedeleg-与-sideleg"><a class="header" href="#内核态陷入委托寄存器-sedeleg-与-sideleg">内核态陷入委托寄存器 (<code>sedeleg</code> 与 <code>sideleg</code>)</a></h3>
<p>为提升中断和异常的处理性能，可以实现独立的可读写寄存器 <code>sedeleg</code> 和 <code>sideleg</code>，设置其中的位将特定的中断和异常交由用户态陷入处理程序处理。这两个寄存器与相应的机器态陷入委托寄存器 (<code>medeleg</code> 和 <code>mideleg</code>) 布局相同。只有已经被委托给 S 态的陷入对应的位才是可写的，其余位由硬件保持为 0 ，即只有委托给 S 态的陷入才可能被委托给 U 态。</p>
<p>当一个陷入被委托给一个权限较低的模式 u 时，<code>ucause</code> 寄存器被写入陷阱的原因；<code>uepc</code> 寄存器被写入发生陷阱的指令的虚拟地址；<code>utval</code> 寄存器被写入一个特定的异常数据；<code>mstatus</code> 的 UPIE 字段被写入陷阱发生时 UIE 字段的值；<code>mstatus</code> 的 UIE 字段被清零。<code>mcause</code>/<code>scause</code> 和 <code>mepc</code>/<code>sepc</code> 寄存器以及 <code>mstatus</code> 的 MPP 和 MPIE 字段不被写入。</p>
<p>一个实现不应硬性规定任何委托位为一，也就是说，任何可以被委托的陷阱都必须支持不被委托。一个实现方案是选择可委托的陷入的子集。支持的可委托位可通过向每个比特位置写 1，然后读回 <code>medeleg</code>/<code>sedeleg</code> 或 <code>mideleg</code>/<code>sideleg</code> 中的值，看看哪些位上有 1。</p>
<blockquote>
<p>目前，不支持触发低权限级的陷入</p>
</blockquote>
<p>不会在用户态发生的应硬件恒零，如 ECall from S/H/M-mode</p>
<h3 id="uscratch"><a class="header" href="#uscratch">uscratch</a></h3>
<p><code>uscratch</code> 寄存器是一个 UXLEN 位读/写寄存器。</p>
<h3 id="用户异常程序计数器-uepc"><a class="header" href="#用户异常程序计数器-uepc">用户异常程序计数器 (<code>uepc</code>)</a></h3>
<p><code>uepc</code> 是 UXLEN 位的可读写寄存器。最低位（<code>uepc[0]</code>）恒为零。次低位 <code>uepc[1]</code> 视实现的对齐需求而定。</p>
<p><code>uepc</code> 是 WARL 寄存器，必须能存储所有有效的虚拟地址，但不需要能够存储所有可能的无效地址。实现可以先将一些非法地址转为其他非法地址再写入 <code>uepc</code>。</p>
<p>当陷入在用户态处理时，被中断或触发异常的指令的虚拟地址被写入 <code>uepc</code>，除此之外 <code>uepc</code> 永远不会被硬件实现写入，但可能被软件显式写入。</p>
<h3 id="用户陷入原因寄存器-ucause"><a class="header" href="#用户陷入原因寄存器-ucause">用户陷入原因寄存器 (<code>ucause</code>)</a></h3>
<pre><code>| Interrupt | Exception Code (WLRL) |
</code></pre>
<p><code>ucause</code> 是 UXLEN 位长读写寄存器。当陷入在用户态处理时，触发陷入的事件编号被写入 <code>ucause</code>，除此之外 <code>ucause</code> 永远不会被硬件实现写入，但可能被软件显式写入。</p>
<table><thead><tr><th>Interrupt</th><th>Exception Code</th><th>Description</th></tr></thead><tbody>
<tr><td>1</td><td>0</td><td>用户态软件中断</td></tr>
<tr><td>1</td><td>1-3</td><td><em>预留</em></td></tr>
<tr><td>1</td><td>4</td><td>用户态时钟中断</td></tr>
<tr><td>1</td><td>5-7</td><td><em>预留</em></td></tr>
<tr><td>1</td><td>8</td><td>用户态外部中断</td></tr>
<tr><td>1</td><td>9-15</td><td><em>预留</em></td></tr>
<tr><td>1</td><td>≥16</td><td><em>由平台使用</em></td></tr>
<tr><td>0</td><td>0</td><td>指令地址未对齐</td></tr>
<tr><td>0</td><td>1</td><td>指令访问错误</td></tr>
<tr><td>0</td><td>2</td><td>非法指令</td></tr>
<tr><td>0</td><td>3</td><td>断点</td></tr>
<tr><td>0</td><td>4</td><td>加载地址未对齐</td></tr>
<tr><td>0</td><td>5</td><td>加载访问错误</td></tr>
<tr><td>0</td><td>6</td><td>存储/原子内存操作地址未对齐</td></tr>
<tr><td>0</td><td>7</td><td>存储/原子内存操作访问错误</td></tr>
<tr><td>0</td><td>8</td><td>用户态环境调用</td></tr>
<tr><td>0</td><td>9-11</td><td><em>预留</em></td></tr>
<tr><td>0</td><td>12</td><td>指令页错误</td></tr>
<tr><td>0</td><td>13</td><td>加载页错误</td></tr>
<tr><td>0</td><td>14</td><td><em>预留</em></td></tr>
<tr><td>0</td><td>15</td><td>存储/原子内存操作页错误</td></tr>
<tr><td>0</td><td>16-23</td><td><em>预留</em></td></tr>
<tr><td>0</td><td>24-31</td><td><em>自定义用途</em></td></tr>
<tr><td>0</td><td>32-47</td><td><em>预留</em></td></tr>
<tr><td>0</td><td>48-63</td><td><em>自定义用途</em></td></tr>
<tr><td>0</td><td>≥64</td><td><em>预留</em></td></tr>
</tbody></table>
<h3 id="用户陷入值寄存器-utval"><a class="header" href="#用户陷入值寄存器-utval">用户陷入值寄存器 (<code>utval</code>)</a></h3>
<p><code>utval</code> 是 UXLEN 位的可读写寄存器。当陷入在用户态处理时，和特定异常相关的信息将被写入 <code>utval</code> 以帮助软件处理陷入，除此之外 <code>utval</code> 永远不会被硬件实现写入，但可能被软件显式写入。硬件平台指定哪些异常必须将信息写入 <code>utval</code> ，以及哪些异常会无条件写入 0 。</p>
<p>当硬件断点被触发，或是一个指令/加载/存储地址未对齐/访问错误/页错误异常产生时，导致错误的虚拟地址被写入 <code>utval</code> 。当非法指令异常产生时，相应指令的前 XLEN 或 ILEN 位可能被写入 <code>utval</code> 。对于其他异常，<code>utval</code> 被置为 0 ，但未来的标准可能重新定义 <code>utval</code> 的设置。</p>
<h2 id="n-扩展的指令"><a class="header" href="#n-扩展的指令">N 扩展的指令</a></h2>
<h3 id="uret"><a class="header" href="#uret">URET</a></h3>
<p><code>uret</code> 将 <code>pc</code> 设置为 <code>uepc</code> ，将 <code>ustatus.UIE</code> 设置为 <code>ustatus.UPIE</code> ，从而恢复中断前的状态。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="用户态中断与异常的处理流程"><a class="header" href="#用户态中断与异常的处理流程">用户态中断与异常的处理流程</a></h1>
<p><img src="assets/user_trap_flow.drawio.svg" alt="用户态中断与异常的处理流程" /></p>
<h2 id="中断的产生"><a class="header" href="#中断的产生">中断的产生</a></h2>
<p>与 M 态和 S 态类似，中断分为软件中断 (Software Interrupt)、时钟中断 (Timer Interrupt) 和外部中断 (External Interrupt)。</p>
<blockquote>
<p>方便起见，三类中断会简称为 xSI、xTI、xEI，其中 x 为特权级。</p>
</blockquote>
<p>硬件或软件将 <code>uip.UXIP</code> (X 表示中断种类) 置为 1 ，硬件检测发现 <code>uip</code> 非零，进入中断的判断流程。</p>
<p>首先检查该中断是否被委托给用户态处理，即 <code>sideleg</code> 寄存器中对应的位是否为 1；如果为真，检查用户态全局中断使能是否为真，即 <code>ustatus.UIE</code> 是否为 1 ；若仍为真，再检查该中断是否被使能，即 <code>uie.UXIE</code> 是否为 1 ；如果还为真，则触发中断处理的流程。</p>
<blockquote>
<p><strong>注意</strong></p>
<p>上述寄存器中，<code>uie</code> <code>uip</code> 为 <code>mie</code> <code>mip</code> 的子集，即读写会同时作用于所有的 <code>xip</code> <code>xie</code> 或它们本就是同一寄存器。而 <code>ustatus</code> 至少 <code>UIE</code> 和 <code>UPIE</code> 与 <code>mstatus</code> 中的相同位相同。</p>
<p>虽然上述中断产生的流程中有判断次序，实际实现中一般使用组合逻辑，将寄存器值进行位与来判断，可以认为是同时判断的。</p>
</blockquote>
<h2 id="异常的产生"><a class="header" href="#异常的产生">异常的产生</a></h2>
<p>当异常发生时，硬件只检查 <code>sedeleg</code> 寄存器中对应的位是否为 1，若为真则触发异常的处理流程。</p>
<p>在 RISC-V 中，中断和异常的处理流程是统一的，下面出于描述简单考虑，多数情况下围绕中断进行描述。</p>
<h2 id="中断的处理"><a class="header" href="#中断的处理">中断的处理</a></h2>
<p>在上述的产生流程后，处理器开始进行一些预处理：</p>
<ul>
<li>设置 <code>ustatus.UPIE</code> 为 <code>ustatus.UIE</code> 的值，并置 <code>ustatus.UIE</code> 为 0</li>
<li>根据中断类型设置 <code>ucause</code></li>
<li>设置 <code>uepc</code> 为发生中断或异常时的 <code>pc</code></li>
<li>(可选) 设置 <code>utval</code></li>
<li>根据 <code>utvec</code> 的最低二位和高位的基地址，跳转到设置好的中断处理程序</li>
</ul>
<p>中断处理程序需要完成以下工作：</p>
<ul>
<li>保存现场</li>
<li>如果 <code>utvec</code> 为 direct 模式，根据 <code>ucause</code> 执行相应的处理程序</li>
<li>如果 <code>utvec</code> 为 vector 模式，执行处理程序</li>
<li>恢复现场</li>
</ul>
<p>中断处理程序通常需要保存和恢复的现场有：</p>
<ul>
<li>x1-x31 通用寄存器 (如果确定中断处理程序中不会使用到某些寄存器，可以省去保存和恢复)</li>
<li><code>ustatus</code> (可能需要通过修改 <code>ustatus</code> 来改变 CPU 状态)</li>
<li><code>uepc</code> (可能需要通过修改进一步触发 S 态的中断/异常)</li>
<li><strong>我们尚未注意到的但需要保存和恢复的寄存器</strong></li>
</ul>
<p><img src="assets/trap.drawio.svg" alt="中断与异常的硬件处理流程" /></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="外部中断与平台级中断控制器plic"><a class="header" href="#外部中断与平台级中断控制器plic">外部中断与平台级中断控制器（PLIC）</a></h1>
<h2 id="外部中断"><a class="header" href="#外部中断">外部中断</a></h2>
<p>外部中断主要用于处理与外设相关的中断，如 GPIO、UART、DMA 等。PLIC 接收所有外设的中断信号，根据程序配置的优先级、阈值和上下文规则，在相应的硬件线程上触发外部中断。程序需要从 PLIC 的 MMIO 寄存器中进一步读取具体的中断外设源信息。</p>
<p><code>mip.MEIP</code> 位对程序是只读的，只能由 PLIC 写入或清除。 <code>mip.SEIP</code> 可读写， M 态程序可以将该位置 1 ，而是否产生 S 态外部中断由该位的值和 PLIC 相应的信号逻辑或的结果决定，二者中任一为 1 即产生中断； <code>csrr</code> 、 <code>csrrs</code> 和 <code>csrrc</code> 指令在该位上的行为略有不同，具体可见规范。 <code>sip.SEIP</code> （对 S 态程序）是只读的。对于用户态中断可以设计类似的约束条件。</p>
<h2 id="plic"><a class="header" href="#plic">PLIC</a></h2>
<p>目前的 <a href="https://github.com/riscv/riscv-plic-spec/blob/master/riscv-plic.adoc">PLIC 规范</a> 支持至多 1024 个（外设）中断源和 15872 套上下文（具体含义将在下文分析），每个中断源可配置 2^32 种优先级，每套上下文可配置 2^32 种优先级阈值，以及在每套上下文中可配置每个中断源是否使能。</p>
<h3 id="中断触发条件"><a class="header" href="#中断触发条件">中断触发条件</a></h3>
<ol>
<li>中断源产生中断等待信号；</li>
<li>在某套上下文中，该中断源被使能；</li>
<li>该中断源的优先级高于该上下文的优先级阈值；</li>
</ol>
<p>上述条件均满足时，PLIC 会在硬件线程中触发外部中断，硬件线程编号与中断的特权级由上下文的设计决定。</p>
<h3 id="上下文"><a class="header" href="#上下文">上下文</a></h3>
<p>上下文指的是特定处理器中，特定硬件线程上的特定特权级，如果 CPU 中有三个硬件线程和两个可以处理中断的特权级（ M 和 S ），那么就存在六套 PLIC 上下文（在某个硬件线程上触发某个特权级的外部中断）。在该场景下，不妨按以下方法对上下文编号：</p>
<table><thead><tr><th></th><th>硬件线程 1</th><th>硬件线程 2</th><th>硬件线程 3</th></tr></thead><tbody>
<tr><td>运行在 M 态</td><td>上下文 1</td><td>上下文 2</td><td>上下文 3</td></tr>
<tr><td>运行在 S 态</td><td>上下文 4</td><td>上下文 5</td><td>上下文 6</td></tr>
</tbody></table>
<p>设某个中断源符合上下文 1 、4 和 6 的中断触发条件，那么 PLIC 会在硬件线程 1 上同时触发 MEI 和 SEI，在硬件线程 3 上触发 SEI ；在硬件线程 2 上，该中断源不会触发外部中断。</p>
<h3 id="中断领取与完成"><a class="header" href="#中断领取与完成">中断领取与完成</a></h3>
<p>PLIC 中每套上下文具有一个领取/完成（<code>claim/complete</code>）寄存器。程序读取该寄存器时，PLIC 会返回该上下文中优先级最高、等待信号有效且被使能的中断源编号（该中断源的优先级可以低于上下文阈值），同时清除该中断源的等待位，并屏蔽其信号。
程序向该寄存器中写入一个中断编号以通知 PLIC 该中断处理完成，若相应中断源在其上下文中被使能，则 PLIC 解除相应的屏蔽，否则忽略本次写入。</p>
<h2 id="用户态外部中断设计"><a class="header" href="#用户态外部中断设计">用户态外部中断设计</a></h2>
<p>实现了 N 扩展的系统可以将外部中断发送至用户态程序进行处理，以提高用户态驱动程序的效率。我们认为，这种场景对外部中断有如下需求：</p>
<ol>
<li>实时性：外部中断由外设触发，触发时机和传递的信息基本不受硬件线程控制，程序应及时处理，降低丢失信息的风险；</li>
<li>隔离性：不开启虚拟化的情况下，机器中通常只存在一个内核，不需要考虑中断如何分发；但用户态通常有多个进程同时（或分时复用）运行，A 外设不应导致 B 外设的用户态驱动或其他不相关的进程进入中断；</li>
<li>安全性：中断源的优先级和不同上下文中的使能应当由内核设置，用户态程序不能任意修改；</li>
<li>兼容性：外部中断应当与现有操作系统的若干机制能够良好兼容，如基于页表的地址空间映射、基于时间片的分时复用等。</li>
</ol>
<p>基于以上需求和现有的外部中断与 PLIC 规范，我们提出如下设计方案：</p>
<ol>
<li>对于每个硬件线程，M、S 和 U 态各自占有一套 PLIC 上下文；</li>
<li>当某个外设的驱动进程被调度到一个硬件线程上运行时，内核将该硬件线程上该外设对应的中断在 U 态上下文中使能，并在 S 态上下文中关闭，将 U 态上下文相应领取/完成寄存器映射到驱动地址空间中，这样当该外设产生中断时，会在该硬件线程上产生 UEI 供驱动处理；</li>
<li>当普通进程被调度运行时，将该硬件线程的 uie.UEIE 位置 0 ，全局关闭 UEI ，同时将外设对应的中断在 S 态上下文中使能，以确保可以接收到外设中断；当系统中有多个硬件线程时，可以设计均衡方案，使得同一外设只在某一个硬件线程的上下文中被使能；</li>
<li>非驱动进程因 SEI 进入内核后，内核应尽快将相应的驱动进程调度运行；可能需要由内核完成中断领取/完成过程，取出中断源编号，再通过将 sip.UEIP 置 1 实现中断转发；</li>
<li>PLIC 规范中各部分地址空间基本对齐到 4KB 边界，可以将中断源优先级、等待位、使能位对应的地址空间全部映射到内核中；</li>
<li>对于实时性要求较高的外设，内核可以提高其驱动进程优先级，甚至将其长期绑定在一个核上轮询中断是否产生。</li>
</ol>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="硬件与模拟器"><a class="header" href="#硬件与模拟器">硬件与模拟器</a></h1>
<blockquote>
<p>本节介绍硬件与模拟器中实现的主要特性</p>
<p>可以在 <a href="ch1_n_ext_spec.html">N 扩展规范草案</a> 一节看到完整的 N 扩展及相关寄存器描述。在 <a href="ch1_use_of_user_mode_trap.html">用户态中断的使用</a> 一节中看到关于用户态中断使用的描述。</p>
</blockquote>
<h2 id="qemu-with-extension-n"><a class="header" href="#qemu-with-extension-n">QEMU with extension N</a></h2>
<p>出于稳定性考虑，我们选择以 <a href="https://github.com/qemu/qemu/tree/stable-5.0">QEMU 的 5.0 稳定分支</a> 为基础，添加用户态中断所需的寄存器和相应的中断处理函数。</p>
<ul>
<li>添加寄存器 <code>ustatus</code> <code>uip</code> <code>uie</code> <code>sideleg</code> <code>sedeleg</code> <code>uepc</code> <code>utvec</code> <code>ucause</code> <code>utval</code> <code>uscratch</code></li>
<li>添加用户态中断的触发部分：符合条件时使上述处理器进入中断状态</li>
<li>实现 <code>uret</code> 指令</li>
</ul>
<p>一个使用修改后的 QEMU 进行的用户态中断的简单测试结果：</p>
<p><img src="assets/user_mode_trap_test.png" alt="user mode trap test" /></p>
<p>图中的 <code>user soft</code> 为用户态的中断处理程序接收到 <code>user soft interrupt</code> 后输出的信息，<code>user mode</code> 为用户态程序输出的信息。</p>
<h2 id="labeled-risc-v-cpu"><a class="header" href="#labeled-risc-v-cpu">Labeled RISC-V CPU</a></h2>
<h3 id="设计目标"><a class="header" href="#设计目标">设计目标</a></h3>
<p>本设计将 uCore-SMP 系统适配到标签化 RISC-V 架构的 FPGA 版本上，并基于二者在内核中实现调度进程所使用的 LLC 和内存带宽资源的功能，提供相应的接口和演示程序，对资源调度的效果进行展示。</p>
<h3 id="设计方案"><a class="header" href="#设计方案">设计方案</a></h3>
<h4 id="硬件"><a class="header" href="#硬件">硬件</a></h4>
<p>设计使用标签化 RISC-V 架构的 FPGA 版本和赛灵思公司的 ZCU102 开发板，搭载一颗 Zynq® UltraScale+™ XCZU9EG-2FFVB1156E MPSoC 。该芯片的处理系统（PS）部分具有四个 Arm A53 核心，运行 Linux 系统，主要功能为烧写 FPGA 比特流，辅助其复位和启动，并转发串口数据。可编程逻辑（PL）部分实现为四个 Rocket Core，ISA 为 RV64IMAC，时钟频率 100MHz，具有 2MB 共享 L2 缓存和 2GB DRAM 。</p>
<p>标签化 RISC-V 架构在每个核心上添加了一个 CSR 记录当前核心上正在运行的程序的标签，并使用该标签标记程序的资源请求。该寄存器编号为 0x9C0 ，访问权限为 S 态可读写。标签控制平面以 MMIO 形式映射到 0x20000 地址，可以向其中写入标签的缓存和内存控制参数，并读取标签对应的 L1 到 L2 的流量。</p>
<p>L2 缓存被划分为 16 块，使用位掩码对标签对应进程可用的缓存区域进行控制，若某位为 1 ，则表示该进程可以使用该块缓存；反之则不能。若某块缓存在多个标签的掩码中均为 1 ，则该块缓存由这些标签对应的进程共享。</p>
<p>内存带宽使用令牌桶算法进行控制。每个标签有一个令牌桶，控制器每隔 <code>freq</code> 个时钟周期会向桶中放入 <code>inc</code> 个令牌，桶的容量为 <code>size</code> ，当令牌数量达到桶容量时，令牌数量不再增加。一个令牌对应 64 比特的数据量，进程每次发起一次内存读写请求，会消耗标签令牌桶中相应数据量的令牌，当桶中没有令牌时，请求会被挂起。当进程持续访问内存时，其最大内存带宽近似为 \(inc\cdot{clock\over freq}\cdot 64 ,\mathrm{bps}\) 。</p>
<h4 id="固件lrv-rust-bl"><a class="header" href="#固件lrv-rust-bl">固件：lrv-rust-bl</a></h4>
<p>该部分基于 RustSBI 的 QEMU 参考实现进行开发，使用 Rust 语言编写。PL 所用串口外设为 UART Lite，与 QEMU 中所用的 NS16550A 不同，需要重新实现其初始化和收发代码。</p>
<p>该 RISC-V 核心不支持非对齐 load/store 指令，此类指令会触发相应的非对齐异常，但同时内核和应用程序中又无法完全避免这些指令，为了实现二者的兼容，固件在相应的异常处理例程中解码触发异常的指令，根据其选择的寄存器和非对齐地址偏移量，使用两次对齐的 load/store 进行模拟。需要注意的是，该平台同时支持压缩指令（C）扩展，因而指令长度可能为 2 或 4 字节，指令本身可能处于非对齐地址上，且 load 和 store 各有三种（常规指令、基于通用寄存器中地址的压缩指令、基于栈指针寄存器中地址的压缩指令），指令格式不尽相同，解码过程较为繁琐。</p>
<p>该启动器代码仓库位于 https://github.com/Gallium70/lrv-rust-bl ，对该启动器更详细的介绍见代码仓库中相应的文档。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="用户态中断的管理"><a class="header" href="#用户态中断的管理">用户态中断的管理</a></h1>
<h2 id="与其他特权级中断的比较"><a class="header" href="#与其他特权级中断的比较">与其他特权级中断的比较</a></h2>
<p>RISC-V 特权级指令架构规范中已经规定了机器态（M）和内核态（S）的中断规范，以及二者之间的互动机制，如特权级屏蔽、中断委托等。设计用户态（U）中断时，我们在一定程度上参照了现有的 S 态中断机制，并将 M 和 S 之间的关系平移到了 S 和 U 上，以保持整个中断架构的一致性。三种中断的完整处理流程图如下：</p>
<p><img src="assets/full_trap_flow.drawio.svg" alt="完整中断处理流程" /></p>
<p>在同时实现了 M 、S 和 U ，且没有实现 H 扩展的系统上，在 M 态运行的通常只有一个启动器（或者称为 SEE、SBI），且只在启动、发生 SBI 调用和处理部分中断时才执行代码；在 S 态运行的只有一个内核，一部分系统服务的代码可能在处理器上执行较长时间；这两个特权级只需要各自有一个陷入处理函数即可。</p>
<p>而在 U 态运行的通常有大量的用户程序，以时间片的方式轮流占用处理器执行。对于同步异常而言，这通常不构成问题，因为同步异常一定发生在某个程序执行自己的指令时触发；但对于异步中断，其来源往往无法知晓用户进程的状态，后者可能正在运行、处在调度队列中、进入睡眠甚至已经结束，如何确保进程收到自己想要的中断，同时不会错误地收到本应由其他进程处理的中断，就成了使用用户态中断时面临的核心问题。</p>
<h2 id="用户态中断上下文"><a class="header" href="#用户态中断上下文">用户态中断上下文</a></h2>
<p>为了解决上述问题，我们提出了“用户态中断上下文”的概念。用户态中断上下文包括各中断寄存器、外部中断映射和待处理中断记录。进程切换时，内核保存当前进程的用户态中断上下文，恢复下一进程的上下文，从而确保在多进程环境下，进程</p>
<h3 id="中断记录"><a class="header" href="#中断记录">中断记录</a></h3>
<p>在 RISC-V 规范中，中断的原因存储于</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="用户态中断的使用"><a class="header" href="#用户态中断的使用">用户态中断的使用</a></h1>
<blockquote>
<p>本节描述构想中的用户态中断的使用，部分功能细节仍在进一步讨论中</p>
</blockquote>
<h2 id="需要解决的问题"><a class="header" href="#需要解决的问题">需要解决的问题</a></h2>
<p>在一个成熟的操作系统中，同时运行的用户态进程数量是十分庞大的。在传统的实现方案中，这些用户态进程互相之间通信或与外设通信都需要经过内核态，这造成了大量的页表切换等颇具开销的行为。如果可以让用户态进程自己处理不需要内核态权限的中断，应能减少相应的开销，使得操作系统的性能得到提升。</p>
<p>此外，许多需要用户态进程处理的中断并不需要即时处理，引入用户态中断的机制可以在用户态进程被调度的时候再触发，减少对执行情况的干扰。</p>
<h2 id="陷入信息表"><a class="header" href="#陷入信息表">陷入信息表</a></h2>
<p>为解决用户态进程数量过多且不同用户态进程有不同的用户态中断处理程序和中断信息，需添加进程的“陷入信息表” (Trap Information Table, TIT)。其结构和进程控制块的关系如下图：</p>
<p><img src="assets/TIT.drawio.svg" alt="trap info table" /></p>
<p>内核态维护一个先入先出的“陷入信息队列”，当有新的陷入信息时，将其添加至队列的尾部；而在用户态进程被调度时，内核态检查发现有陷入信息时，将相应信息恢复至寄存器，并设置 <code>uip</code> 寄存器。在返回至用户态后，立即触发中断，进入用户态进程自己设定的用户态中断处理程序。</p>
<p><code>utval</code> 寄存器存储中断的具体信息，其结构为：</p>
<pre><code>+-----+------+-----------+
| TAG | TYPE | trap info |
+-----+------+-----------+
</code></pre>
<p><code>TAG</code> 用于记录中断是传递给哪个进程，<code>TYPE</code> 用于进一步区分中断的类别，<code>trap info</code> 则存储中断的更为详细的信息。</p>
<h2 id="中断的响应"><a class="header" href="#中断的响应">中断的响应</a></h2>
<h3 id="即时的中断响应"><a class="header" href="#即时的中断响应">即时的中断响应</a></h3>
<p>用户态可能接收到并即时处理的中断有时钟中断、外部中断以及自行设置的软件中断。当中断发生时，会执行以下步骤：</p>
<ol start="0">
<li>硬件设置用户态寄存器。</li>
<li>检查将要写入 <code>utval</code> 的值中的 <code>TAG</code> 是否为当前正在运行的进程。如果是，触发用户态中断，执行与恢复；如果不是，触发 S 态中断。</li>
<li>进入 S 态中断，根据 <code>TAG</code> 将用户态 CSR 中的值存储在对应进程的 <code>TIT</code> 中，恢复并继续执行原用户态进程。该中断转为另一进程的“非即时中断”。</li>
</ol>
<h3 id="非即时的中断响应"><a class="header" href="#非即时的中断响应">非即时的中断响应</a></h3>
<p>一个进程存在非即时的中断需要响应，即在被调度时其 <code>TIT</code> 非空。操作系统依序执行以下步骤：</p>
<ol start="0">
<li>欲调度该进程，检查 <code>TIT</code> ，发现存在需要处理的陷入信息。</li>
<li>内核态构造 <code>trap frame</code> ，将 <code>trap info</code> 中的 <code>ucause</code> 和 <code>utval</code> 放入 <code>trap frame</code> 中，并设置 <code>uip</code> 中对应位，设置 <code>ustatus.UPIE</code>。使用 <code>uret</code> 返回用户态</li>
<li><code>uret</code> 根据 <code>utatus.UPIE</code> 设置 <code>ustatus.UIE</code> ，用户态中断全局使能被开启。</li>
<li>触发用户态中断，进入 <code>utvec</code> 对应的用户态中断处理程序，保存现场。</li>
<li>查看 <code>ucause</code> 和 <code>utval</code> ，选择对应的处理分支。</li>
<li>处理完成后，恢复现场，恢复用户态进程的运行。</li>
</ol>
<h2 id="应用示例"><a class="header" href="#应用示例">应用示例</a></h2>
<h3 id="跨进程信号示例"><a class="header" href="#跨进程信号示例">跨进程“信号”示例</a></h3>
<p>假设在一个单核、支持 N 扩展的 CPU 上运行一支持用户态中断的操作系统，有进程 A 和进程 B，且有某种机制使它们互相知道彼此的 <code>pid</code>。</p>
<ol>
<li>进程 A 执行 <code>ecall</code> ，触发内核态中断，并通过寄存器 <code>a0-a7</code> 传递参数：跨进程信号，发送目标 B，传递信息 <code>0x1</code>。</li>
<li>进入内核态中断处理程序 <code>ecall</code> 分支，根据寄存器值判断为“跨进程信号”，开始构造 B 的 <code>trap info</code>：
<ul>
<li>构造 <code>utval</code>：<code>| TAG::B_pid | TYPE::cross_process_signal | trap_info ( src_pid: A_pid, info: 0x1 ) |</code></li>
<li>构造 <code>uip</code>：<code>| 0x0 | USIP ( 1 ) | 0x0 |</code> (挂起用户态软件中断)</li>
<li>构造 <code>ucause</code>: <code>0x8000_0000_0000_0000</code> (用户态软件中断)</li>
</ul>
</li>
<li>将 <code>trap info</code> 存入 B 的 <code>TIT</code>，恢复 A 的运行。</li>
<li>时间片轮转或 A 主动让权，开始调度 B。</li>
<li>内核态检查 <code>TIT</code> 非空，开始构建 <code>trap frame</code>：
<ul>
<li>根据 <code>PCB</code> 中的 <code>Trap Context</code> ，设置寄存器 <code>x1-x31</code> <code>utvec</code> <code>uie</code> <code>ustatus</code> <code>uepc</code></li>
<li>从 <code>PCB</code> 指向的 <code>TIT</code> 取出第一个 <code>trap info</code> ，根据内容设置寄存器 <code>utval</code> <code>uip</code> <code>ucause</code></li>
</ul>
</li>
<li>使用 <code>uret</code> 恢复进入用户态：
<ul>
<li>通过 <code>pc = uepc</code> 恢复为上次运行时间片最后的 <code>pc</code></li>
<li>通过 <code>ustatus.UIE = ustatus.UPIE</code> 开启用户态中断全局使能，允许中断发生</li>
</ul>
</li>
<li>中断发生，跳转 <code>utvec</code> 对应的用户态中断处理程序，保存现场。</li>
<li>通过查看 <code>utval</code> 和 <code>ucause</code> 知道是来自 A 的跨进程信号，进入相应分支处理。</li>
<li>处理完毕，恢复现场，继续执行 B 进程。</li>
</ol>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="使用方法"><a class="header" href="#使用方法">使用方法</a></h1>
<p>克隆仓库：</p>
<pre><code class="language-sh">git clone https://github.com/Gallium70/rv-n-ext-impl.git
cd rv-n-ext-impl
</code></pre>
<p>本仓库中包含多个子模组，不同的子模组之间并不一定能够组合出合理的搭配，故<strong>不建议</strong>直接使用 <code>git clone --recurse-submodules</code> 或是 <code>git clone --recurse-submodules</code> 一次性初始化所有的子模组，而是分别使用 <code>git submodule update --init xxx</code> 进行初始化。</p>
<h2 id="环境配置"><a class="header" href="#环境配置">环境配置</a></h2>
<p>主要开发环境为 Ubuntu 20.04 (WSL) ，其中一些使用 Rust 编写的项目在 Windows 下也可编译，Rust 环境配置可参考 <a href="https://rcore-os.github.io/rCore-Tutorial-Book-v3/chapter0/5setup-devel-env.html#rust">rCore-Tutorial</a>。
QEMU 的环境配置见 <a href="https://wiki.qemu.org/Hosts/Linux#Building_QEMU_for_Linux">Building QEMU for Linux</a>（我们推荐的编译路径和选项与此文中有所不同）；此外 QEMU 还提供了 <a href="https://wiki.qemu.org/Hosts/W32#Building_QEMU_for_W64">Windows 环境下的编译指南</a> ，但我们没有测试过。</p>
<h2 id="在-qemu-上运行-rcore-n"><a class="header" href="#在-qemu-上运行-rcore-n">在 QEMU 上运行 rCore-N</a></h2>
<h3 id="qemu"><a class="header" href="#qemu">QEMU</a></h3>
<pre><code class="language-sh">git submodule update --init qemu
cd qemu-build
../qemu/configure --target-list=&quot;riscv64-softmmu&quot;
make -j
</code></pre>
<p>我们选择在 qemu 文件夹之外（而非在其中创建子文件夹）进行编译是为了避免编译产生的大量中间文件被 git 追踪。
编译产生的可执行文件为 qemu-build/riscv64-softmmu/qemu-system-riscv64 。</p>
<p>调试 PLIC 可修改 <a href="../../qemu/hw/riscv/sifive_plic.c">sifive_plic.c</a> 中 <code>RISCV_DEBUG_PLIC</code> 宏的值为 1，然后在 qemu-build 目录中重新使用 <code>make -j</code> 编译。</p>
<h3 id="rcore-n"><a class="header" href="#rcore-n">rCore-N</a></h3>
<p>justfile 中默认将 QEMU 的两个串口映射到了 /dev/pts/1 和 /dev/pts/2 ，可以在 Linux 中新打开两个终端，执行 <code>tty</code> 指令查看对应的设备路径，替换掉 justfile 中 -serial 后面的参数，并在新终端中执行 <a href="../../rCore-N/sleep.sh">sleep.sh</a> ，确保键盘输入传入了 QEMU 串口而非 shell 的 stdin/stdout 。
后续可能使用 tmux 重写这一步骤，省去手动配置的过程。</p>
<p>编译、运行：</p>
<pre><code class="language-sh">git submodule update --init rCore-N
cd rCore-N/os
just run
</code></pre>
<p>在 <code>just</code> 指令前设置 <code>LOG</code> 环境变量可以指定 rCore-N 的日志等级，如 <code>LOG=DEBUG just run</code> 会将日志等级设为 DEBUG 。</p>
<p>调试 rCore-N 可使用 <code>just debug</code> ，打开 QEMU 的调试输出使用 <code>just debug_qemu</code> 。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="成果示例"><a class="header" href="#成果示例">成果示例</a></h1>
<h2 id="标签-risc-v-cpu-与-标签化-ucore-smp"><a class="header" href="#标签-risc-v-cpu-与-标签化-ucore-smp">标签 RISC-V CPU 与 标签化 uCore-SMP</a></h2>
<p>FPGA 平台内存带宽约 12MB/s ，测试场景如 <a href="ch4_0_test_and_demo.html#dsid_demo">“dsid_demo”章节</a> 中所述。测试结果如下：</p>
<p>可见在存在干扰情况下，给排序程序分配内存带宽越多，其性能越接近不受干扰时的情形，显示出内存带宽调控的效果；当内存带宽 7:2 分配时，控制缓存性能较优，而 8:1 分配时，不控制缓存缓存性能较优，这可能是因为缓存的分配比例介于二者之间，8:1 分配时，若不控制缓存，排序程序对缓存的利用率可以高于 7:2 时。</p>
<h3 id="后续优化方向"><a class="header" href="#后续优化方向">后续优化方向</a></h3>
<ol>
<li>自动和闭环控制：将应用的服务质量需求描述自动转换为标签系统的控制参数，并不断监测调节，提高灵活性、准确性和鲁棒性；</li>
<li>延迟控制：增加对应用服务延迟的测量和监测机制，展示标签系统控制延迟波动、提高用户体验的功能；</li>
<li>适配更多资源和场景：如图形计算的算力和存储、分布式系统中跨结点的标签传递、嵌入式平台中的实时性保证；</li>
<li>更多启动器功能：添加 Remote Fence、Hart 状态管理等 SBI 扩展，为操作系统提供更完善的支持。</li>
</ol>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
