<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Risc-V Extension N Implementation</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> 简介</a></li><li class="chapter-item expanded "><a href="ch1_0_ext_spec.html"><strong aria-hidden="true">2.</strong> N 扩展规范 (草案)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch1_1_user_trap_flow.html"><strong aria-hidden="true">2.1.</strong> 用户态中断的处理流程</a></li></ol></li><li class="chapter-item expanded "><a href="ch2_0_design.html"><strong aria-hidden="true">3.</strong> 设计</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch2_1_trap_comparison.html"><strong aria-hidden="true">3.1.</strong> 与其他特权级中断的比较</a></li><li class="chapter-item expanded "><a href="ch2_2_usage_of_user_mode_trap.html"><strong aria-hidden="true">3.2.</strong> 用户态中断的使用方案</a></li><li class="chapter-item expanded "><a href="ch2_3_external_interrupt_and_plic.html"><strong aria-hidden="true">3.3.</strong> 外部中断与 PLIC</a></li><li class="chapter-item expanded "><a href="ch2_4_user_trap_management.html"><strong aria-hidden="true">3.4.</strong> 用户态中断的管理</a></li><li class="chapter-item expanded "><a href="ch2_5_user_trap_pros_and_cons.html"><strong aria-hidden="true">3.5.</strong> 用户态中断的利与弊</a></li><li class="chapter-item expanded "><a href="ch2_6_label_system.html"><strong aria-hidden="true">3.6.</strong> 标签系统</a></li></ol></li><li class="chapter-item expanded "><a href="ch3_0_implementation.html"><strong aria-hidden="true">4.</strong> 实现</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch3_1_hardware_and_emulator.html"><strong aria-hidden="true">4.1.</strong> 硬件与模拟器</a></li><li class="chapter-item expanded "><a href="ch3_2_bootloader.html"><strong aria-hidden="true">4.2.</strong> 启动器与 SBI</a></li><li class="chapter-item expanded "><a href="ch3_3_kernel.html"><strong aria-hidden="true">4.3.</strong> 操作系统内核</a></li><li class="chapter-item expanded "><a href="ch3_4_user_app.html"><strong aria-hidden="true">4.4.</strong> 用户应用程序</a></li></ol></li><li class="chapter-item expanded "><a href="ch4_0_demo.html"><strong aria-hidden="true">5.</strong> 演示</a></li><li class="chapter-item expanded "><a href="ch5_0_reference.html"><strong aria-hidden="true">6.</strong> 参考</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Risc-V Extension N Implementation</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="软硬协同的用户态中断"><a class="header" href="#软硬协同的用户态中断">软硬协同的用户态中断</a></h1>
<p>注：<strong>该文档正在修订中，内容可能发生大幅变化</strong></p>
<h2 id="目标"><a class="header" href="#目标">目标</a></h2>
<p>本项目在现有 <a href="https://five-embeddev.com/riscv-isa-manual/latest/n.html">RISC-V 用户态中断扩展规范草案</a> 的基础上将其进一步完善，提出一种符合该规范的模拟器和 FPGA 实现，并基于用户态中断在内核中实现优化的信号和 io_uring 等跨进程通信机制，展示其设计和性能优势。</p>
<h2 id="项目设计"><a class="header" href="#项目设计">项目设计</a></h2>
<p>项目架构设计如下：</p>
<p><img src="assets/proj.svg" alt="arch" /></p>
<ul>
<li>模拟器：修改 QEMU 5.0，在其中添加 N 扩展支持</li>
<li>FPGA：基于中科院计算所的<a href="https://github.com/LvNA-system/labeled-RISC-V/tree/master/fpga">标签化 RISC-V 架构</a>，添加 N 扩展支持</li>
<li>启动器与 SBI：在 FPGA 平台上使用基于 RustSBI 开发的 <a href="https://github.com/Gallium70/lrv-rust-bl">lrv-rust-bl</a> ，在 QEMU 上 uCore-SMP 系统使用 OpenSBI ，rCore 系统使用 RustSBI</li>
<li>操作系统：选择 <a href="https://github.com/TianhuaTao/uCore-SMP">uCore-SMP</a> 和 <a href="https://github.com/duskmoon314/rCore-N">rCore-N</a></li>
</ul>
<h3 id="文件结构"><a class="header" href="#文件结构">文件结构</a></h3>
<pre><code>.
├── README.md
├── docs                docs in mdbook structure
├── Labeled-uCore-SMP   uCore SMP with labeled RISC-V support
├── lrv-rust-bl         Labeled RISC-V fpga bootloader based on RustSBI
├── qemu                qemu modified by Campbell He
├── qemu-build          folder holding qemu build artifacts
├── rCore-N             rCore with N extension
└── rv-csr-test         N extension simple test program
</code></pre>
<h2 id="开发进展"><a class="header" href="#开发进展">开发进展</a></h2>
<h3 id="qemu-与-fpga"><a class="header" href="#qemu-与-fpga">QEMU 与 FPGA</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
在 QEMU 中添加 N 扩展支持</li>
<li><input disabled="" type="checkbox" checked=""/>
在 FPGA 开发板上部署标签化 RISC-V 架构</li>
<li><input disabled="" type="checkbox"/>
增加 N 扩展的 Chisel 代码</li>
</ul>
<h3 id="操作系统"><a class="header" href="#操作系统">操作系统</a></h3>
<ul>
<li>rCore
<ul>
<li><input disabled="" type="checkbox" checked=""/>
添加 N 扩展支持</li>
<li><input disabled="" type="checkbox"/>
适配 FPGA 平台</li>
<li><input disabled="" type="checkbox"/>
适配标签机制</li>
<li><input disabled="" type="checkbox"/>
多核支持</li>
<li><input disabled="" type="checkbox" checked=""/>
实现信号机制</li>
<li><input disabled="" type="checkbox"/>
实现 io_uring</li>
</ul>
</li>
<li>uCore-SMP
<ul>
<li><input disabled="" type="checkbox"/>
添加 N 扩展支持</li>
<li><input disabled="" type="checkbox" checked=""/>
适配 FPGA 平台</li>
<li><input disabled="" type="checkbox" checked=""/>
适配标签机制</li>
<li><input disabled="" type="checkbox"/>
实现信号机制</li>
<li><input disabled="" type="checkbox"/>
实现 io_uring</li>
</ul>
</li>
</ul>
<h3 id="应用程序"><a class="header" href="#应用程序">应用程序</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
验证 N 扩展正常工作</li>
<li><input disabled="" type="checkbox" checked=""/>
信号机制测例</li>
<li><input disabled="" type="checkbox"/>
io_uring 测例</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="n-扩展规范-草案"><a class="header" href="#n-扩展规范-草案">N 扩展规范 (草案)</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="用户态中断与异常的处理流程"><a class="header" href="#用户态中断与异常的处理流程">用户态中断与异常的处理流程</a></h1>
<p><img src="assets/user_trap_flow.drawio.svg" alt="用户态中断与异常的处理流程" /></p>
<h2 id="中断的产生"><a class="header" href="#中断的产生">中断的产生</a></h2>
<p>与 M 态和 S 态类似，中断分为软件中断 (Software Interrupt)、时钟中断 (Timer Interrupt) 和外部中断 (External Interrupt)。</p>
<blockquote>
<p>方便起见，三类中断会简称为 xSI、xTI、xEI，其中 x 为特权级。</p>
</blockquote>
<p>硬件或软件将 <code>uip.UXIP</code> (X 表示中断种类) 置为 1 ，硬件检测发现 <code>uip</code> 非零，进入中断的判断流程。</p>
<p>首先检查该中断是否被委托给用户态处理，即 <code>sideleg</code> 寄存器中对应的位是否为 1；如果为真，检查用户态全局中断使能是否为真，即 <code>ustatus.UIE</code> 是否为 1 ；若仍为真，再检查该中断是否被使能，即 <code>uie.UXIE</code> 是否为 1 ；如果还为真，则触发中断处理的流程。</p>
<blockquote>
<p><strong>注意</strong></p>
<p>上述寄存器中，<code>uie</code> <code>uip</code> 为 <code>mie</code> <code>mip</code> 的子集，即读写会同时作用于所有的 <code>xip</code> <code>xie</code> 或它们本就是同一寄存器。而 <code>ustatus</code> 至少 <code>UIE</code> 和 <code>UPIE</code> 与 <code>mstatus</code> 中的相同位相同。</p>
<p>虽然上述中断产生的流程中有判断次序，实际实现中一般使用组合逻辑，将寄存器值进行位与来判断，可以认为是同时判断的。</p>
</blockquote>
<h2 id="异常的产生"><a class="header" href="#异常的产生">异常的产生</a></h2>
<p>当异常发生时，硬件只检查 <code>sedeleg</code> 寄存器中对应的位是否为 1，若为真则触发异常的处理流程。</p>
<p>在 RISC-V 中，中断和异常的处理流程是统一的，下面出于描述简单考虑，多数情况下围绕中断进行描述。</p>
<h2 id="中断的处理"><a class="header" href="#中断的处理">中断的处理</a></h2>
<p>在上述的产生流程后，处理器开始进行一些预处理：</p>
<ul>
<li>设置 <code>ustatus.UPIE</code> 为 <code>ustatus.UIE</code> 的值，并置 <code>ustatus.UIE</code> 为 0</li>
<li>根据中断类型设置 <code>ucause</code></li>
<li>设置 <code>uepc</code> 为发生中断或异常时的 <code>pc</code></li>
<li>(可选) 设置 <code>utval</code></li>
<li>根据 <code>utvec</code> 的最低二位和高位的基地址，跳转到设置好的中断处理程序</li>
</ul>
<p>中断处理程序需要完成以下工作：</p>
<ul>
<li>保存现场</li>
<li>如果 <code>utvec</code> 为 direct 模式，根据 <code>ucause</code> 执行相应的处理程序</li>
<li>如果 <code>utvec</code> 为 vector 模式，执行处理程序</li>
<li>恢复现场</li>
</ul>
<p>中断处理程序通常需要保存和恢复的现场有：</p>
<ul>
<li>x1-x31 通用寄存器 (如果确定中断处理程序中不会使用到某些寄存器，可以省去保存和恢复)</li>
<li><code>ustatus</code> (可能需要通过修改 <code>ustatus</code> 来改变 CPU 状态)</li>
<li><code>uepc</code> (可能需要通过修改进一步触发 S 态的中断/异常)</li>
<li><strong>我们尚未注意到的但需要保存和恢复的寄存器</strong></li>
</ul>
<p><img src="assets/trap.drawio.svg" alt="中断与异常的硬件处理流程" /></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="设计"><a class="header" href="#设计">设计</a></h1>
<p>本章将介绍我们对于本项目的设计思路，即我们“为什么”要这么做。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="用户态中断的使用"><a class="header" href="#用户态中断的使用">用户态中断的使用</a></h1>
<blockquote>
<p>本节描述构想中的用户态中断的使用，部分功能细节仍在进一步讨论中</p>
</blockquote>
<h2 id="需要解决的问题"><a class="header" href="#需要解决的问题">需要解决的问题</a></h2>
<p>在一个成熟的操作系统中，同时运行的用户态进程数量是十分庞大的。在传统的实现方案中，这些用户态进程互相之间通信或与外设通信都需要经过内核态，这造成了大量的页表切换等颇具开销的行为。如果可以让用户态进程自己处理不需要内核态权限的中断，应能减少相应的开销，使得操作系统的性能得到提升。</p>
<p>此外，许多需要用户态进程处理的中断并不需要即时处理，引入用户态中断的机制可以在用户态进程被调度的时候再触发，减少对执行情况的干扰。</p>
<h2 id="陷入信息表"><a class="header" href="#陷入信息表">陷入信息表</a></h2>
<p>为解决用户态进程数量过多且不同用户态进程有不同的用户态中断处理程序和中断信息，需添加进程的“陷入信息表” (Trap Information Table, TIT)。其结构和进程控制块的关系如下图：</p>
<p><img src="assets/TIT.drawio.svg" alt="trap info table" /></p>
<p>内核态维护一个先入先出的“陷入信息队列”，当有新的陷入信息时，将其添加至队列的尾部；而在用户态进程被调度时，内核态检查发现有陷入信息时，将相应信息恢复至寄存器，并设置 <code>uip</code> 寄存器。在返回至用户态后，立即触发中断，进入用户态进程自己设定的用户态中断处理程序。</p>
<p><code>utval</code> 寄存器存储中断的具体信息，其结构为：</p>
<pre><code>+-----+------+-----------+
| TAG | TYPE | trap info |
+-----+------+-----------+
</code></pre>
<p><code>TAG</code> 用于记录中断是传递给哪个进程，<code>TYPE</code> 用于进一步区分中断的类别，<code>trap info</code> 则存储中断的更为详细的信息。</p>
<h2 id="中断的响应"><a class="header" href="#中断的响应">中断的响应</a></h2>
<h3 id="即时的中断响应"><a class="header" href="#即时的中断响应">即时的中断响应</a></h3>
<p>用户态可能接收到并即时处理的中断有时钟中断、外部中断以及自行设置的软件中断。当中断发生时，会执行以下步骤：</p>
<ol start="0">
<li>硬件设置用户态寄存器。</li>
<li>检查将要写入 <code>utval</code> 的值中的 <code>TAG</code> 是否为当前正在运行的进程。如果是，触发用户态中断，执行与恢复；如果不是，触发 S 态中断。</li>
<li>进入 S 态中断，根据 <code>TAG</code> 将用户态 CSR 中的值存储在对应进程的 <code>TIT</code> 中，恢复并继续执行原用户态进程。该中断转为另一进程的“非即时中断”。</li>
</ol>
<h3 id="非即时的中断响应"><a class="header" href="#非即时的中断响应">非即时的中断响应</a></h3>
<p>一个进程存在非即时的中断需要响应，即在被调度时其 <code>TIT</code> 非空。操作系统依序执行以下步骤：</p>
<ol start="0">
<li>欲调度该进程，检查 <code>TIT</code> ，发现存在需要处理的陷入信息。</li>
<li>内核态构造 <code>trap frame</code> ，将 <code>trap info</code> 中的 <code>ucause</code> 和 <code>utval</code> 放入 <code>trap frame</code> 中，并设置 <code>uip</code> 中对应位，设置 <code>ustatus.UPIE</code>。使用 <code>uret</code> 返回用户态</li>
<li><code>uret</code> 根据 <code>utatus.UPIE</code> 设置 <code>ustatus.UIE</code> ，用户态中断全局使能被开启。</li>
<li>触发用户态中断，进入 <code>utvec</code> 对应的用户态中断处理程序，保存现场。</li>
<li>查看 <code>ucause</code> 和 <code>utval</code> ，选择对应的处理分支。</li>
<li>处理完成后，恢复现场，恢复用户态进程的运行。</li>
</ol>
<h2 id="应用示例"><a class="header" href="#应用示例">应用示例</a></h2>
<h3 id="跨进程信号示例"><a class="header" href="#跨进程信号示例">跨进程“信号”示例</a></h3>
<p>假设在一个单核、支持 N 扩展的 CPU 上运行一支持用户态中断的操作系统，有进程 A 和进程 B，且有某种机制使它们互相知道彼此的 <code>pid</code>。</p>
<ol>
<li>进程 A 执行 <code>ecall</code> ，触发内核态中断，并通过寄存器 <code>a0-a7</code> 传递参数：跨进程信号，发送目标 B，传递信息 <code>0x1</code>。</li>
<li>进入内核态中断处理程序 <code>ecall</code> 分支，根据寄存器值判断为“跨进程信号”，开始构造 B 的 <code>trap info</code>：
<ul>
<li>构造 <code>utval</code>：<code>| TAG::B_pid | TYPE::cross_process_signal | trap_info ( src_pid: A_pid, info: 0x1 ) |</code></li>
<li>构造 <code>uip</code>：<code>| 0x0 | USIP ( 1 ) | 0x0 |</code> (挂起用户态软件中断)</li>
<li>构造 <code>ucause</code>: <code>0x8000_0000_0000_0000</code> (用户态软件中断)</li>
</ul>
</li>
<li>将 <code>trap info</code> 存入 B 的 <code>TIT</code>，恢复 A 的运行。</li>
<li>时间片轮转或 A 主动让权，开始调度 B。</li>
<li>内核态检查 <code>TIT</code> 非空，开始构建 <code>trap frame</code>：
<ul>
<li>根据 <code>PCB</code> 中的 <code>Trap Context</code> ，设置寄存器 <code>x1-x31</code> <code>utvec</code> <code>uie</code> <code>ustatus</code> <code>uepc</code></li>
<li>从 <code>PCB</code> 指向的 <code>TIT</code> 取出第一个 <code>trap info</code> ，根据内容设置寄存器 <code>utval</code> <code>uip</code> <code>ucause</code></li>
</ul>
</li>
<li>使用 <code>uret</code> 恢复进入用户态：
<ul>
<li>通过 <code>pc = uepc</code> 恢复为上次运行时间片最后的 <code>pc</code></li>
<li>通过 <code>ustatus.UIE = ustatus.UPIE</code> 开启用户态中断全局使能，允许中断发生</li>
</ul>
</li>
<li>中断发生，跳转 <code>utvec</code> 对应的用户态中断处理程序，保存现场。</li>
<li>通过查看 <code>utval</code> 和 <code>ucause</code> 知道是来自 A 的跨进程信号，进入相应分支处理。</li>
<li>处理完毕，恢复现场，继续执行 B 进程。</li>
</ol>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="外部中断与平台级中断控制器plic"><a class="header" href="#外部中断与平台级中断控制器plic">外部中断与平台级中断控制器（PLIC）</a></h1>
<h2 id="外部中断"><a class="header" href="#外部中断">外部中断</a></h2>
<p>外部中断主要用于处理与外设相关的中断，如 GPIO、UART、DMA 等。PLIC 接收所有外设的中断信号，根据程序配置的优先级、阈值和上下文规则，在相应的硬件线程上触发外部中断。程序需要从 PLIC 的 MMIO 寄存器中进一步读取具体的中断外设源信息。</p>
<p><code>mip.MEIP</code> 位对程序是只读的，只能由 PLIC 写入或清除。 <code>mip.SEIP</code> 可读写， M 态程序可以将该位置 1 ，而是否产生 S 态外部中断由该位的值和 PLIC 相应的信号逻辑或的结果决定，二者中任一为 1 即产生中断； <code>csrr</code> 、 <code>csrrs</code> 和 <code>csrrc</code> 指令在该位上的行为略有不同，具体可见规范。 <code>sip.SEIP</code> （对 S 态程序）是只读的。对于用户态中断可以设计类似的约束条件。</p>
<h2 id="plic"><a class="header" href="#plic">PLIC</a></h2>
<p>目前的 <a href="https://github.com/riscv/riscv-plic-spec/blob/master/riscv-plic.adoc">PLIC 规范</a> 支持至多 1024 个（外设）中断源和 15872 套上下文（具体含义将在下文分析），每个中断源可配置 2^32 种优先级，每套上下文可配置 2^32 种优先级阈值，以及在每套上下文中可配置每个中断源是否使能。</p>
<h3 id="中断触发条件"><a class="header" href="#中断触发条件">中断触发条件</a></h3>
<ol>
<li>中断源产生中断等待信号；</li>
<li>在某套上下文中，该中断源被使能；</li>
<li>该中断源的优先级高于该上下文的优先级阈值；</li>
</ol>
<p>上述条件均满足时，PLIC 会在硬件线程中触发外部中断，硬件线程编号与中断的特权级由上下文的设计决定。</p>
<h3 id="上下文"><a class="header" href="#上下文">上下文</a></h3>
<p>上下文指的是特定处理器中，特定硬件线程上的特定特权级，如果 CPU 中有三个硬件线程和两个可以处理中断的特权级（ M 和 S ），那么就存在六套 PLIC 上下文（在某个硬件线程上触发某个特权级的外部中断）。在该场景下，不妨按以下方法对上下文编号：</p>
<table><thead><tr><th></th><th>硬件线程 1</th><th>硬件线程 2</th><th>硬件线程 3</th></tr></thead><tbody>
<tr><td>运行在 M 态</td><td>上下文 1</td><td>上下文 2</td><td>上下文 3</td></tr>
<tr><td>运行在 S 态</td><td>上下文 4</td><td>上下文 5</td><td>上下文 6</td></tr>
</tbody></table>
<p>设某个中断源符合上下文 1 、4 和 6 的中断触发条件，那么 PLIC 会在硬件线程 1 上同时触发 MEI 和 SEI，在硬件线程 3 上触发 SEI ；在硬件线程 2 上，该中断源不会触发外部中断。</p>
<h3 id="中断领取与完成"><a class="header" href="#中断领取与完成">中断领取与完成</a></h3>
<p>PLIC 中每套上下文具有一个领取/完成（<code>claim/complete</code>）寄存器。程序读取该寄存器时，PLIC 会返回该上下文中优先级最高、等待信号有效且被使能的中断源编号（该中断源的优先级可以低于上下文阈值），同时清除该中断源的等待位，并屏蔽其信号。
程序向该寄存器中写入一个中断编号以通知 PLIC 该中断处理完成，若相应中断源在其上下文中被使能，则 PLIC 解除相应的屏蔽，否则忽略本次写入。</p>
<h2 id="用户态外部中断设计"><a class="header" href="#用户态外部中断设计">用户态外部中断设计</a></h2>
<p>实现了 N 扩展的系统可以将外部中断发送至用户态程序进行处理，以提高用户态驱动程序的效率。我们认为，这种场景对外部中断有如下需求：</p>
<ol>
<li>实时性：外部中断由外设触发，触发时机和传递的信息基本不受硬件线程控制，程序应及时处理，降低丢失信息的风险；</li>
<li>隔离性：不开启虚拟化的情况下，机器中通常只存在一个内核，不需要考虑中断如何分发；但用户态通常有多个进程同时（或分时复用）运行，A 外设不应导致 B 外设的用户态驱动或其他不相关的进程进入中断；</li>
<li>安全性：中断源的优先级和不同上下文中的使能应当由内核设置，用户态程序不能任意修改；</li>
<li>兼容性：外部中断应当与现有操作系统的若干机制能够良好兼容，如基于页表的地址空间映射、基于时间片的分时复用等。</li>
</ol>
<p>基于以上需求和现有的外部中断与 PLIC 规范，我们提出如下设计方案：</p>
<ol>
<li>对于每个硬件线程，M、S 和 U 态各自占有一套 PLIC 上下文；</li>
<li>当某个外设的驱动进程被调度到一个硬件线程上运行时，内核将该硬件线程上该外设对应的中断在 U 态上下文中使能，并在 S 态上下文中关闭，将 U 态上下文相应领取/完成寄存器映射到驱动地址空间中，这样当该外设产生中断时，会在该硬件线程上产生 UEI 供驱动处理；</li>
<li>当普通进程被调度运行时，将该硬件线程的 uie.UEIE 位置 0 ，全局关闭 UEI ，同时将外设对应的中断在 S 态上下文中使能，以确保可以接收到外设中断；当系统中有多个硬件线程时，可以设计均衡方案，使得同一外设只在某一个硬件线程的上下文中被使能；</li>
<li>非驱动进程因 SEI 进入内核后，内核应尽快将相应的驱动进程调度运行；可能需要由内核完成中断领取/完成过程，取出中断源编号，再通过将 sip.UEIP 置 1 实现中断转发；</li>
<li>PLIC 规范中各部分地址空间基本对齐到 4KB 边界，可以将中断源优先级、等待位、使能位对应的地址空间全部映射到内核中；</li>
<li>对于实时性要求较高的外设，内核可以提高其驱动进程优先级，甚至将其长期绑定在一个核上轮询中断是否产生。</li>
</ol>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="用户态中断的管理"><a class="header" href="#用户态中断的管理">用户态中断的管理</a></h1>
<h2 id="与其他特权级中断的比较"><a class="header" href="#与其他特权级中断的比较">与其他特权级中断的比较</a></h2>
<p>RISC-V 特权级指令架构规范中已经规定了机器态（M）和内核态（S）的中断规范，以及二者之间的互动机制，如特权级屏蔽、中断委托等。设计用户态（U）中断时，我们在一定程度上参照了现有的 S 态中断机制，并将 M 和 S 之间的关系平移到了 S 和 U 上，以保持整个中断架构的一致性。三种中断的完整处理流程图如下：</p>
<p><img src="assets/full_trap_flow.drawio.svg" alt="完整中断处理流程" /></p>
<p>在同时实现了 M 、S 和 U ，且没有实现 H 扩展的系统上，在 M 态运行的通常只有一个启动器（或者称为 SEE、SBI），且只在启动、发生 SBI 调用和处理部分中断时才执行代码；在 S 态运行的只有一个内核，一部分系统服务的代码可能在处理器上执行较长时间；这两个特权级只需要各自有一个陷入处理函数即可。</p>
<p>而在 U 态运行的通常有大量的用户程序，以时间片的方式轮流占用处理器执行。对于同步异常而言，这通常不构成问题，因为同步异常一定发生在某个程序执行自己的指令时触发；但对于异步中断，其来源往往无法知晓用户进程的状态，后者可能正在运行、处在调度队列中、进入睡眠甚至已经结束，如何确保进程收到自己想要的中断，同时不会错误地收到本应由其他进程处理的中断，就成了使用用户态中断时面临的核心问题。</p>
<h2 id="用户态中断上下文"><a class="header" href="#用户态中断上下文">用户态中断上下文</a></h2>
<p>为了解决上述问题，我们提出了“用户态中断上下文”的概念，用于记录用户态进程的中断使能、待处理中断请求、中断向量基址等信息。进程切换时，内核保存当前进程的上下文，恢复出下一进程的上下文，从而使每个进程的中断配置不会被进程调度破坏。</p>
<p>由于调度间隔较长，</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="硬件与模拟器"><a class="header" href="#硬件与模拟器">硬件与模拟器</a></h1>
<blockquote>
<p>本节介绍硬件与模拟器中实现的主要特性</p>
<p>可以在 <a href="ch1_n_ext_spec.html">N 扩展规范草案</a> 一节看到完整的 N 扩展及相关寄存器描述。在 <a href="ch1_use_of_user_mode_trap.html">用户态中断的使用</a> 一节中看到关于用户态中断使用的描述。</p>
</blockquote>
<h2 id="qemu-with-extension-n"><a class="header" href="#qemu-with-extension-n">QEMU with extension N</a></h2>
<p>出于稳定性考虑，我们选择以 <a href="https://github.com/qemu/qemu/tree/stable-5.0">QEMU 的 5.0 稳定分支</a> 为基础，添加用户态中断所需的寄存器和相应的中断处理函数。</p>
<ul>
<li>添加寄存器 <code>ustatus</code> <code>uip</code> <code>uie</code> <code>sideleg</code> <code>sedeleg</code> <code>uepc</code> <code>utvec</code> <code>ucause</code> <code>utval</code> <code>uscratch</code></li>
<li>添加用户态中断的触发部分：符合条件时使上述处理器进入中断状态</li>
<li>实现 <code>uret</code> 指令</li>
</ul>
<p>一个使用修改后的 QEMU 进行的用户态中断的简单测试结果：</p>
<p><img src="assets/user_mode_trap_test.png" alt="user mode trap test" /></p>
<p>图中的 <code>user soft</code> 为用户态的中断处理程序接收到 <code>user soft interrupt</code> 后输出的信息，<code>user mode</code> 为用户态程序输出的信息。</p>
<h2 id="labeled-risc-v-cpu"><a class="header" href="#labeled-risc-v-cpu">Labeled RISC-V CPU</a></h2>
<h3 id="设计目标"><a class="header" href="#设计目标">设计目标</a></h3>
<p>本设计将 uCore-SMP 系统适配到标签化 RISC-V 架构的 FPGA 版本上，并基于二者在内核中实现调度进程所使用的 LLC 和内存带宽资源的功能，提供相应的接口和演示程序，对资源调度的效果进行展示。</p>
<h3 id="设计方案"><a class="header" href="#设计方案">设计方案</a></h3>
<h4 id="硬件"><a class="header" href="#硬件">硬件</a></h4>
<p>设计使用标签化 RISC-V 架构的 FPGA 版本和赛灵思公司的 ZCU102 开发板，搭载一颗 Zynq® UltraScale+™ XCZU9EG-2FFVB1156E MPSoC 。该芯片的处理系统（PS）部分具有四个 Arm A53 核心，运行 Linux 系统，主要功能为烧写 FPGA 比特流，辅助其复位和启动，并转发串口数据。可编程逻辑（PL）部分实现为四个 Rocket Core，ISA 为 RV64IMAC，时钟频率 100MHz，具有 2MB 共享 L2 缓存和 2GB DRAM 。</p>
<p>标签化 RISC-V 架构在每个核心上添加了一个 CSR 记录当前核心上正在运行的程序的标签，并使用该标签标记程序的资源请求。该寄存器编号为 0x9C0 ，访问权限为 S 态可读写。标签控制平面以 MMIO 形式映射到 0x20000 地址，可以向其中写入标签的缓存和内存控制参数，并读取标签对应的 L1 到 L2 的流量。</p>
<p>L2 缓存被划分为 16 块，使用位掩码对标签对应进程可用的缓存区域进行控制，若某位为 1 ，则表示该进程可以使用该块缓存；反之则不能。若某块缓存在多个标签的掩码中均为 1 ，则该块缓存由这些标签对应的进程共享。</p>
<p>内存带宽使用令牌桶算法进行控制。每个标签有一个令牌桶，控制器每隔 <code>freq</code> 个时钟周期会向桶中放入 <code>inc</code> 个令牌，桶的容量为 <code>size</code> ，当令牌数量达到桶容量时，令牌数量不再增加。一个令牌对应 64 比特的数据量，进程每次发起一次内存读写请求，会消耗标签令牌桶中相应数据量的令牌，当桶中没有令牌时，请求会被挂起。当进程持续访问内存时，其最大内存带宽近似为 \(inc\cdot{clock\over freq}\cdot 64 ,\mathrm{bps}\) 。</p>
<h4 id="固件lrv-rust-bl"><a class="header" href="#固件lrv-rust-bl">固件：lrv-rust-bl</a></h4>
<p>该部分基于 RustSBI 的 QEMU 参考实现进行开发，使用 Rust 语言编写。PL 所用串口外设为 UART Lite，与 QEMU 中所用的 NS16550A 不同，需要重新实现其初始化和收发代码。</p>
<p>该 RISC-V 核心不支持非对齐 load/store 指令，此类指令会触发相应的非对齐异常，但同时内核和应用程序中又无法完全避免这些指令，为了实现二者的兼容，固件在相应的异常处理例程中解码触发异常的指令，根据其选择的寄存器和非对齐地址偏移量，使用两次对齐的 load/store 进行模拟。需要注意的是，该平台同时支持压缩指令（C）扩展，因而指令长度可能为 2 或 4 字节，指令本身可能处于非对齐地址上，且 load 和 store 各有三种（常规指令、基于通用寄存器中地址的压缩指令、基于栈指针寄存器中地址的压缩指令），指令格式不尽相同，解码过程较为繁琐。</p>
<p>该启动器代码仓库位于 https://github.com/Gallium70/lrv-rust-bl ，对该启动器更详细的介绍见代码仓库中相应的文档。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="操作系统-1"><a class="header" href="#操作系统-1">操作系统</a></h1>
<p>我们选择基于 <a href="https://github.com/TianhuaTao/uCore-SMP/tree/label-riscv">TianhuaTao/uCore-SMP</a> 和 rCore，加入用户态中断和标签的支持，完成软硬件的协同。</p>
<h1 id="操作系统标签化-ucore-smp"><a class="header" href="#操作系统标签化-ucore-smp">操作系统：标签化 uCore-SMP</a></h1>
<p>uCore-SMP 在设计时目标平台为 QEMU ，将其移植到 FPGA 平台主要需要解决如下问题：内存布局、时钟周期、页表项属性和硬盘外设。移植完成后，还需添加对标签系统的支持。代码仓库位于 https://github.com/TianhuaTao/uCore-SMP/tree/label-riscv 。</p>
<h2 id="内存布局"><a class="header" href="#内存布局">内存布局</a></h2>
<p>QEMU 中内存的起始地址为 0x80000000 ，而 FPGA 平台起始地址为 0x100000000 ，相应的内核启动地址也要调整到 0x100200000 ，这两个值需要在 <code>memory_layout.h</code> 和 <code>kernelld.py</code> 中进行修改。QEMU 中配置总内存空间为 128MB，而尽管 FPGA 平台有 2GB DRAM，由于内存带宽有限，uCore-SMP 在启动时又会将所有内存地址遍历并初始化。为了减少操作系统的启动等待时间，综合考虑内核和用户程序所需的内存空间，最终将可分配的内存限制在 32MB 。</p>
<h2 id="时钟周期"><a class="header" href="#时钟周期">时钟周期</a></h2>
<p>QEMU 中 CPU 运行频率（即 <code>cycle</code> 寄存器的增加频率）为 3GHz ，而实时时钟（RTC）频率（即 <code>time</code> 寄存器的增加频率）为 12.5MHz ；FPGA 平台上 CPU 频率为 100MHz ，RTC 频率为 10MHz，需要在 <code>timer.h</code> 中修改。</p>
<h2 id="页表项属性"><a class="header" href="#页表项属性">页表项属性</a></h2>
<p>根据 RISC-V 规范中虚拟内存章节的描述，页表项中有“已访问（A）”和“已修改（D）”两个标志位，对这两个标志位，规范允许两种处理方式：</p>
<blockquote>
<ul>
<li>When a virtual page is accessed and the A bit is clear, or is written and the D bit is clear, a page-fault exception is raised.</li>
<li>When a virtual page is accessed and the A bit is clear, or is written and the D bit is clear, the implementation sets the corresponding bit(s) in the PTE. The PTE update must be atomic with respect to other accesses to the PTE, and must atomically check that the PTE is valid and grants sufficient permissions. The PTE update must be exact (i.e., not speculative), and observed in program order by the local hart. Furthermore, the PTE update must appear in the global memory order no later than the explicit memory access, or any subsequent explicit memory access to that virtual page by the local hart. The ordering on loads and stores provided by FENCE instructions and the acquire/release bits on atomic instructions also orders the PTE updates associated with those loads and stores as observed by remote harts.</li>
</ul>
</blockquote>
<p>即直接触发页错误异常，或由硬件实现直接对页表项置位。FPGA 平台实现为前一种，而 QEMU 为后一种。这两个标志位主要应用于虚拟存储系统中的页面置换，而 uCore-SMP 中对此并无支持，简单起见，可修改 <code>virtual.c</code> ，在分配新的页表项并映射物理页时，直接将 A 和 D 置位。</p>
<h2 id="硬盘外设"><a class="header" href="#硬盘外设">硬盘外设</a></h2>
<p>QEMU 中通过 virtio 提供了虚拟块存储设备，FPGA 平台中没有。在此情况下，为了仍然能够使用文件系统，陶天骅同学提供了虚拟磁盘接口和 ramdisk 功能，通过宏开关在编译期进行切换。系统初始化时， ramdisk 将在内存中开辟一块区域，并将其按照 nfs 格式进行初始化。</p>
<h2 id="标签系统"><a class="header" href="#标签系统">标签系统</a></h2>
<p>在内核初始化时，将标签系统控制平面基址以恒等映射挂载到 0x20000 地址处，权限为内核可读写。读取和写入参数的方式为基址+偏移，偏移量单位为 32bit ，即需要将地址强制转换为指向 32 位无符号整数的指针类型。具体各参数的偏移量和写入方法见 <code>dsid.c/h</code> 。</p>
<p>目前该系统支持至多 8 个不同的进程标签。进程标签存储于进程控制块中，在程序上下文切换时，内核将标签写入相应的 CSR 。内核的进程标签硬编码为 0 。</p>
<p>内核提供三个和标签相关的系统调用：</p>
<pre><code class="language-c">int set_dsid(int pid, uint32 dsid);
int set_dsid_param(uint32 dsid, uint32 freq, uint32 size, uint32 inc, uint32 mask);
uint32 get_l2_traffic(uint32 dsid);
</code></pre>
<ul>
<li><code>set_dsid</code> 将 <code>pid</code> 对应进程的标签设为 <code>dsid</code> ，若进程不存在，则返回 -1 ，否则返回 0 ；</li>
<li><code>set_dsid_param</code> 设置 <code>dsid</code> 标签相应的令牌桶参数和缓存掩码，参数含义见<a href="ch3_3_kernel.html#%E7%A1%AC%E4%BB%B6">“硬件”章节</a>。只有非零的参数会被写入控制平面。</li>
<li><code>get_l2_traffic</code> 读取 <code>dsid</code> 标签对应的 L1 和 L2 缓存之间的数据流量，单位为 64bit 。</li>
</ul>
<h2 id="与内核共同调试和-debug"><a class="header" href="#与内核共同调试和-debug">与内核共同调试和 debug</a></h2>
<p>标签系统开发过程中，主要查出内核中以下几个缺陷。</p>
<h3 id="调度器初值"><a class="header" href="#调度器初值">调度器初值</a></h3>
<p>uCore-SMP 使用 stride 算法进行调度，在初始实现中，fork 产生的子进程的 stride 会置为 0 。在使用标签系统监测负载程序的缓存性能时，设置父进程每隔一秒输出一次信息。第一批负载表现正常，但启动第二波负载时，会出现直到负载运行结束父进程才会输出的情况。分析后发现，由于子进程 stride 为 0 ，而运行第二波负载时，父进程已有一定的 stride ，此时调度器会持续优先调度子进程，导致父进程陷入“饥饿”。解决方法为，将子进程的 stride 置为和父进程相同。</p>
<h3 id="子进程回收内存泄露"><a class="header" href="#子进程回收内存泄露">子进程回收内存泄露</a></h3>
<p>初始实现中，若父进程没有使用 wait/waitpid 等待子进程结束，则子进程占用的内存和文件等资源在进程结束后不会被回收，当大量 fork 时会耗尽系统内存。为此，陶天骅同学在内核中加入了 reparent 机制，当进程退出时会检查其子进程，若子进程已退出则回收，否则将其父进程置为 NULL ；若退出的进程父进程为 NULL ，则立即回收自身占用的资源，这样解决了这一内存泄露问题。</p>
<h3 id="syscall-中的悬垂指针"><a class="header" href="#syscall-中的悬垂指针">syscall 中的悬垂指针</a></h3>
<p>系统调用进入内核中 syscall 函数时，会保存进程的 trapframe 地址，在具体系统调用执行完成后，使用该地址中的 a0 寄存器保存系统调用的返回值。在运行标签负载时发现，当用户程序运行到 0x1070 地址（用户态下的虚拟地址）时会触发非法指令异常，stval 寄存器显示相应的指令值为 0 ，但查看相应程序的反汇编发现此处并非 0 。起初怀疑是固件中非对齐 load/store 模拟存在问题，导致加载用户程序时出现数据异常；尽管发现固件确实存在问题，但解决该问题后依然会触发非法指令异常。</p>
<p>后来使用内核中 pushtrace 工具在各处记录 0x1070 对应内存地址的数值发现，当执行 execv 系统调用时，会回收原有的 trapframe 内存页，该页可能被后续用于加载用户程序的代码段，程序分配的新 trapframe 的 a0 和 a1 寄存器会分别用于存储 <code>argc</code> 和 <code>argv</code> ；但 execv 执行完成返回 syscall 函数中时（其返回值总为 0 ），仍会使用旧的 trapframe 地址，而 a0 寄存器对应变量在 trapframe 中相应的偏移量即为 0x70 ，向其中写入 0 会破坏用户程序代码，导致错误。解决方法为，当系统调用为 execv 时，在 syscall 函数中不写入 <code>trapframe-&gt;a0</code> 。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="应用程序-1"><a class="header" href="#应用程序-1">应用程序</a></h1>
<p>为了使用标签系统，测量和展示标签系统的控制效果，设计了以下几个用户态应用程序：sort、jammer、prime、monitor、dsid_demo。</p>
<h2 id="sort"><a class="header" href="#sort">sort</a></h2>
<p>对 501202 个 32 位无符号整数，使用基数排序法进行排序，基为 65536 ，数据使用随机数生成器和固定的种子生成，并使用 sharedmem 作为动态申请内存的方式。每个进程会将自己的 pid 加入共享内存名字中，以确保多个负载不会申请到同一块共享内存。程序将自身的运行时间作为返回值，单位是毫秒。</p>
<p>这是一个内存密集型负载，消耗约 4.5MB 内存空间和 8MB/s 的内存带宽。</p>
<h2 id="prime"><a class="header" href="#prime">prime</a></h2>
<p>计算 2 到 52021 之间质数的个数。使用朴素算法，对于每个数 x ，枚举 2 到 x/2 之间的数，判断是否能够整除 x，若能，则 x 不是质数。这是一个计算密集型负载，可以用于验证多核正常运行，且运行时间几乎不受内存带宽限制的影响。</p>
<h2 id="jammer"><a class="header" href="#jammer">jammer</a></h2>
<p>这是一个干扰负载，在一个有 524288 个 32 位无符号整数的数组上随机进行读写，消耗内存带宽。申请内存的方式与 sort 程序相同，消耗约 2MB 内存空间和 8MB/s 的内存带宽。</p>
<h2 id="monitor"><a class="header" href="#monitor">monitor</a></h2>
<p>一个监测系统资源使用状况的程序，监测的资源包括 CPU 使用率、可用内存空间、各进程的运行时间、状态和内存占用、各标签的 L1 和 L2 之间的流量。每隔一秒输出一次，运行十秒后退出。其中 CPU 、内存和进程使用设备文件抽象接口，标签流量使用 <code>get_l2_traffic</code> 系统调用。运行界面如下：</p>
<p><img src="assets/monitor.png" alt="monitor UI" /></p>
<h2 id="dsid_demo"><a class="header" href="#dsid_demo">dsid_demo</a></h2>
<p>本程序中内置了若干组令牌桶和缓存掩码参数用于分配给指定的负载，并执行 <code>monitor</code> 程序监测系统资源的使用情况。</p>
<p>使用方法为 <code>dsid_demo app1 param1 [app2 param2 [app3 param3]]</code> ，最多同时启动 3 个负载。例如， <code>dsid_demo sort 2 prime 1</code> 将为 <code>sort</code> 进程分配 2 号参数组，为 <code>prime</code> 进程分配 1 号参数组。由于可用的标签数量有限，同时为了方便监测起见，标签并不与参数组一一对应，而是为每个负载分配不同的标签，<code>appX</code> 的标签编号即为 X 。在上例中， <code>sort</code> 进程标签为 1 ，而 <code>prime</code> 进程标签为 2 。</p>
<p>各组参数具体的设计，是为了实现以下四种测试场景：</p>
<ul>
<li>不调控</li>
<li>内存带宽 5M：5M，缓存 768K：768K</li>
<li>内存带宽 7M：2M，缓存 1280K：256K</li>
<li>内存带宽 8M：1M，缓存 1280K：256K</li>
</ul>
<p>内置参数组如下（其中 size 参数值均为 0x800）：</p>
<table><thead><tr><th align="center">编号</th><th align="center">freq</th><th align="center">inc</th><th align="center">cache mask</th><th>备注</th></tr></thead><tbody>
<tr><td align="center">0</td><td align="center">10000</td><td align="center">40</td><td align="center">0x000F</td><td>用于内核进程和监测程序，内存带宽约 3MB/s ，<br/>缓存 512K，与其他参数组隔离</td></tr>
<tr><td align="center">1</td><td align="center">100</td><td align="center">100</td><td align="center">0xFFF0</td><td>内存带宽不限，缓存 1536K</td></tr>
<tr><td align="center">2</td><td align="center">7800</td><td align="center">80</td><td align="center">0xFFC0</td><td>内存带宽约 8MB/s ，缓存 1280K</td></tr>
<tr><td align="center">3</td><td align="center">7800</td><td align="center">10</td><td align="center">0x0030</td><td>内存带宽约 1MB/s ，缓存 256K</td></tr>
<tr><td align="center">4</td><td align="center">7800</td><td align="center">80</td><td align="center">0xFFF0</td><td>内存带宽约 8MB/s ，缓存 1536K</td></tr>
<tr><td align="center">5</td><td align="center">7800</td><td align="center">10</td><td align="center">0xFFF0</td><td>内存带宽约 1MB/s ，缓存 1536K</td></tr>
<tr><td align="center">6</td><td align="center">100</td><td align="center">100</td><td align="center">0xFFC0</td><td>内存带宽不限，缓存 1280K</td></tr>
<tr><td align="center">7</td><td align="center">100</td><td align="center">100</td><td align="center">0x0030</td><td>内存带宽不限，缓存 256K</td></tr>
<tr><td align="center">8</td><td align="center">9300</td><td align="center">60</td><td align="center">0x03F0</td><td>内存带宽约 5MB/s ，缓存 768K</td></tr>
<tr><td align="center">9</td><td align="center">9300</td><td align="center">60</td><td align="center">0xFC00</td><td>内存带宽约 5MB/s ，缓存 768K</td></tr>
<tr><td align="center">10</td><td align="center">9300</td><td align="center">60</td><td align="center">0xFFF0</td><td>内存带宽约 5MB/s ，缓存 1536K</td></tr>
<tr><td align="center">11</td><td align="center">100</td><td align="center">100</td><td align="center">0x03F0</td><td>内存带宽不限，缓存 768K</td></tr>
<tr><td align="center">12</td><td align="center">100</td><td align="center">100</td><td align="center">0xFC00</td><td>内存带宽不限，缓存 768K</td></tr>
<tr><td align="center">13</td><td align="center">7800</td><td align="center">70</td><td align="center">0xFFC0</td><td>内存带宽约 7MB/s ，缓存 1280K</td></tr>
<tr><td align="center">14</td><td align="center">7800</td><td align="center">20</td><td align="center">0x0030</td><td>内存带宽约 2MB/s ，缓存 256K</td></tr>
<tr><td align="center">15</td><td align="center">7800</td><td align="center">70</td><td align="center">0xFFF0</td><td>内存带宽约 7MB/s ，缓存 1536K</td></tr>
<tr><td align="center">16</td><td align="center">7800</td><td align="center">20</td><td align="center">0xFFF0</td><td>内存带宽约 2MB/s ，缓存 1536K</td></tr>
</tbody></table>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="成果示例"><a class="header" href="#成果示例">成果示例</a></h1>
<h2 id="标签-risc-v-cpu-与-标签化-ucore-smp"><a class="header" href="#标签-risc-v-cpu-与-标签化-ucore-smp">标签 RISC-V CPU 与 标签化 uCore-SMP</a></h2>
<p>FPGA 平台内存带宽约 12MB/s ，测试场景如 <a href="ch4_0_demo.html#dsid_demo">“dsid_demo”章节</a> 中所述。测试结果如下：</p>
<p>可见在存在干扰情况下，给排序程序分配内存带宽越多，其性能越接近不受干扰时的情形，显示出内存带宽调控的效果；当内存带宽 7:2 分配时，控制缓存性能较优，而 8:1 分配时，不控制缓存缓存性能较优，这可能是因为缓存的分配比例介于二者之间，8:1 分配时，若不控制缓存，排序程序对缓存的利用率可以高于 7:2 时。</p>
<h3 id="后续优化方向"><a class="header" href="#后续优化方向">后续优化方向</a></h3>
<ol>
<li>自动和闭环控制：将应用的服务质量需求描述自动转换为标签系统的控制参数，并不断监测调节，提高灵活性、准确性和鲁棒性；</li>
<li>延迟控制：增加对应用服务延迟的测量和监测机制，展示标签系统控制延迟波动、提高用户体验的功能；</li>
<li>适配更多资源和场景：如图形计算的算力和存储、分布式系统中跨结点的标签传递、嵌入式平台中的实时性保证；</li>
<li>更多启动器功能：添加 Remote Fence、Hart 状态管理等 SBI 扩展，为操作系统提供更完善的支持。</li>
</ol>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="参考"><a class="header" href="#参考">参考</a></h1>
<ul>
<li><a href="https://github.com/riscv/riscv-isa-manual">RISC-V Instruction Set Manual</a></li>
<li><a href="https://man7.org/linux/man-pages/man7/cgroups.7.html">cgroups(7) — Linux manual page</a></li>
<li><a href="https://www.intel.cn/content/www/cn/zh/architecture-and-technology/resource-director-technology.html">英特尔 ® 资源调配技术 (英特尔 ® RDT)</a></li>
<li><a href="https://developer.arm.com/documentation/ddi0598/latest">Arm Architecture Reference Manual Supplement Memory System Resource Partitioning and Monitoring (MPAM), for Armv8-A</a></li>
<li><a href="https://carrv.github.io/2017/papers/yu-labeled_riscv-carrv2017.pdf">Labeled RISC-V: A New Perspective on Software-Defined Architecture</a></li>
<li><a href="https://github.com/TianhuaTao/uCore-SMP/">uCore-SMP GitHub 仓库</a></li>
<li><a href="https://github.com/LvNA-system/labeled-RISC-V/tree/master/fpga">labeled-RISC-V GitHub 仓库</a></li>
<li><a href="https://www.xilinx.com/products/boards-and-kits/ek-u1-zcu102-g.html">Zynq UltraScale+ MPSoC ZCU102 Evaluation Kit</a></li>
<li><a href="https://github.com/chipsalliance/rocket-chip">Rocket Chip Generator</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/164503398">令牌桶工作原理</a></li>
<li><a href="https://github.com/luojia65/rustsbi/tree/master/platform/qemu">RustSBI GitHub 仓库</a></li>
<li><a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_uartlite/v2_0/pg142-axi-uartlite.pdf">AXI UART Lite v2.0 LogiCORE IP Product Guide</a></li>
<li><a href="https://five-embeddev.com/riscv-isa-manual/latest/supervisor.html#sec:translation">RISC-V Page-Based Virtual-Memory Systems</a></li>
<li><a href="https://github.com/Gallium70/labeled-RISC-V-reproduction-note">在 FPGA 上复现标签化 RISC-V 架构——踩坑指南</a></li>
<li><a href="https://github.com/Gallium70/lrv-rust-bl">Labeled RISC-V Rust Bootloader GitHub 仓库</a></li>
<li><a href="https://github.com/TianhuaTao/uCore-SMP/tree/label-riscv">标签化 uCore-SMP GitHub 仓库</a></li>
<li><a href="https://github.com/Gallium70/labeled-RISC-V-boot">labeled-RISC-V-boot GitHub 仓库</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
