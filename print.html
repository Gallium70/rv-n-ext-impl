<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Risc-V Extension N Implementation</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> 简介</a></li><li class="chapter-item expanded "><a href="ch1_hardware.html"><strong aria-hidden="true">2.</strong> 硬件与模拟器</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch1_extN.html"><strong aria-hidden="true">2.1.</strong> N 扩展</a></li><li class="chapter-item expanded "><a href="ch1_use_of_user_mode_trap.html"><strong aria-hidden="true">2.2.</strong> 用户态中断的使用</a></li></ol></li><li class="chapter-item expanded "><a href="ch2_os.html"><strong aria-hidden="true">3.</strong> 操作系统</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch2_uCore.html"><strong aria-hidden="true">3.1.</strong> 标签化 uCore-SMP</a></li></ol></li><li class="chapter-item expanded "><a href="ch3_app.html"><strong aria-hidden="true">4.</strong> 应用程序</a></li><li class="chapter-item expanded "><a href="ch4_example.html"><strong aria-hidden="true">5.</strong> 成果示例</a></li><li class="chapter-item expanded "><a href="ch5_reference.html"><strong aria-hidden="true">6.</strong> 参考</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Risc-V Extension N Implementation</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="软硬协同的用户态中断"><a class="header" href="#软硬协同的用户态中断">软硬协同的用户态中断</a></h1>
<h2 id="目标"><a class="header" href="#目标">目标</a></h2>
<p>本项目旨在提供一种符合 <a href="https://five-embeddev.com/riscv-isa-manual/latest/n.html">RISC-V 用户态中断扩展规范（草案）</a> 的模拟器和 FPGA 实现，并基于用户态中断在内核中实现优化的信号和 io_uring 等跨进程通信机制，展示其设计和性能优势。</p>
<h2 id="项目设计"><a class="header" href="#项目设计">项目设计</a></h2>
<p>项目架构设计如下：</p>
<p><img src="assets/proj.svg" alt="arch" /></p>
<ul>
<li>模拟器：修改 QEMU 5.0，在其中添加 N 扩展支持</li>
<li>FPGA：基于中科院计算所的<a href="https://github.com/LvNA-system/labeled-RISC-V/tree/master/fpga">标签化 RISC-V 架构</a>，添加 N 扩展支持</li>
<li>启动器与 SBI：在 FPGA 平台上使用基于 RustSBI 开发的 <a href="https://github.com/Gallium70/lrv-rust-bl">lrv-rust-bl</a> ，在 QEMU 上 uCore-SMP 系统使用 OpenSBI ，rCore 系统使用 RustSBI</li>
<li>操作系统：选择 <a href="https://github.com/TianhuaTao/uCore-SMP">uCore-SMP</a> 和 <a href="https://github.com/rcore-os/rCore">rCore</a></li>
</ul>
<h3 id="文件结构"><a class="header" href="#文件结构">文件结构</a></h3>
<pre><code>.
├── README.md
├── docs            docs in mdbook structure
├── qemu            qemu modified by Campbell He
└── qemu-build      Where we recommend building qemu here
</code></pre>
<h2 id="开发进展"><a class="header" href="#开发进展">开发进展</a></h2>
<h3 id="qemu-与-fpga"><a class="header" href="#qemu-与-fpga">QEMU 与 FPGA</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
在 QEMU 中添加 N 扩展支持</li>
<li><input disabled="" type="checkbox" checked=""/>
在 FPGA 开发板上部署标签化 RISC-V 架构</li>
<li><input disabled="" type="checkbox"/>
增加 N 扩展的 Chisel 代码</li>
</ul>
<h3 id="操作系统"><a class="header" href="#操作系统">操作系统</a></h3>
<ul>
<li>rCore
<ul>
<li><input disabled="" type="checkbox"/>
添加 N 扩展支持</li>
<li><input disabled="" type="checkbox"/>
适配 FPGA 平台</li>
<li><input disabled="" type="checkbox"/>
适配标签机制</li>
<li><input disabled="" type="checkbox"/>
实现信号机制</li>
<li><input disabled="" type="checkbox"/>
实现 io_uring</li>
</ul>
</li>
<li>uCore-SMP
<ul>
<li><input disabled="" type="checkbox"/>
添加 N 扩展支持</li>
<li><input disabled="" type="checkbox" checked=""/>
适配 FPGA 平台</li>
<li><input disabled="" type="checkbox" checked=""/>
适配标签机制</li>
<li><input disabled="" type="checkbox"/>
实现信号机制</li>
<li><input disabled="" type="checkbox"/>
实现 io_uring</li>
</ul>
</li>
</ul>
<h3 id="应用程序"><a class="header" href="#应用程序">应用程序</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
验证 N 扩展正常工作</li>
<li><input disabled="" type="checkbox"/>
信号机制测例</li>
<li><input disabled="" type="checkbox"/>
io_uring 测例</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="硬件与模拟器"><a class="header" href="#硬件与模拟器">硬件与模拟器</a></h1>
<blockquote>
<p>本节介绍硬件与模拟器中实现的主要特性</p>
<p>可以在 <a href="ch1_extN.html">N 扩展</a> 一节看到完整的 N 扩展及相关寄存器描述。在 <a href="ch1_use_of_user_mode_trap.html">用户态中断的使用</a> 一节中看到关于用户态中断使用的描述。</p>
</blockquote>
<h2 id="qemu-with-extension-n"><a class="header" href="#qemu-with-extension-n">QEMU with extension N</a></h2>
<p>出于稳定性考虑，我们选择以 <a href="https://github.com/qemu/qemu/tree/stable-5.0">QEMU 的 5.0 稳定分支</a> 为基础，添加用户态中断所需的寄存器和相应的中断处理函数。</p>
<ul>
<li>添加寄存器 <code>ustatus</code> <code>uip</code> <code>uie</code> <code>sideleg</code> <code>sedeleg</code> <code>uepc</code> <code>utvec</code> <code>ucause</code> <code>utval</code> <code>uscratch</code></li>
<li>添加用户态中断的触发部分：符合条件时使用上述处理器进入中断状态</li>
<li>实现 <code>uret</code> 指令</li>
</ul>
<p>一个使用修改后的 QEMU 进行的用户态中断的简单测试结果：</p>
<p><img src="assets/user_mode_trap_test.png" alt="user mode trap test" /></p>
<p>图中的 <code>user soft</code> 为用户态的中断处理程序接收到 <code>user soft interrupt</code> 后输出的信息，<code>user mode</code> 为用户态程序输出的信息。</p>
<h3 id="n-扩展实现简述"><a class="header" href="#n-扩展实现简述">N 扩展实现简述</a></h3>
<p>QEMU 的中断检测方式为每个 block 运行前后调用 <code>riscv_cpu_local_irq_pending</code> 函数。其中会查看 <code>mip</code> 是否非零，非零位对应的 <code>mie</code> 是否非零。同时检查特权级和相应的 <code>mideleg</code> <code>medeleg</code> 寄存器与 <code>mstatus.XIE</code> 的全局中断使能位。</p>
<h2 id="labeled-risc-v-cpu"><a class="header" href="#labeled-risc-v-cpu">Labeled RISC-V CPU</a></h2>
<h3 id="设计目标"><a class="header" href="#设计目标">设计目标</a></h3>
<p>本设计将 uCore-SMP 系统适配到标签化 RISC-V 架构的 FPGA 版本上，并基于二者在内核中实现调度进程所使用的 LLC 和内存带宽资源的功能，提供相应的接口和演示程序，对资源调度的效果进行展示。</p>
<h3 id="设计方案"><a class="header" href="#设计方案">设计方案</a></h3>
<h4 id="硬件"><a class="header" href="#硬件">硬件</a></h4>
<p>设计使用标签化 RISC-V 架构的 FPGA 版本和赛灵思公司的 ZCU102 开发板，搭载一颗 Zynq® UltraScale+™ XCZU9EG-2FFVB1156E MPSoC 。该芯片的处理系统（PS）部分具有四个 Arm A53 核心，运行 Linux 系统，主要功能为烧写 FPGA 比特流，辅助其复位和启动，并转发串口数据。可编程逻辑（PL）部分实现为四个 Rocket Core，ISA 为 RV64IMAC，时钟频率 100MHz，具有 2MB 共享 L2 缓存和 2GB DRAM 。</p>
<p>标签化 RISC-V 架构在每个核心上添加了一个 CSR 记录当前核心上正在运行的程序的标签，并使用该标签标记程序的资源请求。该寄存器编号为 0x9C0 ，访问权限为 S 态可读写。标签控制平面以 MMIO 形式映射到 0x20000 地址，可以向其中写入标签的缓存和内存控制参数，并读取标签对应的 L1 到 L2 的流量。</p>
<p>L2 缓存被划分为 16 块，使用位掩码对标签对应进程可用的缓存区域进行控制，若某位为 1 ，则表示该进程可以使用该块缓存；反之则不能。若某块缓存在多个标签的掩码中均为 1 ，则该块缓存由这些标签对应的进程共享。</p>
<p>内存带宽使用令牌桶算法进行控制。每个标签有一个令牌桶，控制器每隔 <code>freq</code> 个时钟周期会向桶中放入 <code>inc</code> 个令牌，桶的容量为 <code>size</code> ，当令牌数量达到桶容量时，令牌数量不再增加。一个令牌对应 64 比特的数据量，进程每次发起一次内存读写请求，会消耗标签令牌桶中相应数据量的令牌，当桶中没有令牌时，请求会被挂起。当进程持续访问内存时，其最大内存带宽近似为 \(inc\cdot{clock\over freq}\cdot 64 ,\mathrm{bps}\) 。</p>
<h4 id="固件lrv-rust-bl"><a class="header" href="#固件lrv-rust-bl">固件：lrv-rust-bl</a></h4>
<p>该部分基于 RustSBI 的 QEMU 参考实现进行开发，使用 Rust 语言编写。PL 所用串口外设为 UART Lite，与 QEMU 中所用的 NS16550A 不同，需要重新实现其初始化和收发代码。</p>
<p>该 RISC-V 核心不支持非对齐 load/store 指令，此类指令会触发相应的非对齐异常，但同时内核和应用程序中又无法完全避免这些指令，为了实现二者的兼容，固件在相应的异常处理例程中解码触发异常的指令，根据其选择的寄存器和非对齐地址偏移量，使用两次对齐的 load/store 进行模拟。需要注意的是，该平台同时支持压缩指令（C）扩展，因而指令长度可能为 2 或 4 字节，指令本身可能处于非对齐地址上，且 load 和 store 各有三种（常规指令、基于通用寄存器中地址的压缩指令、基于栈指针寄存器中地址的压缩指令），指令格式不尽相同，解码过程较为繁琐。</p>
<p>该启动器代码仓库位于 https://github.com/Gallium70/lrv-rust-bl ，对该启动器更详细的介绍见代码仓库中相应的文档。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="n-扩展----omit-in-toc---"><a class="header" href="#n-扩展----omit-in-toc---">N 扩展 <!-- omit in toc --></a></h1>
<blockquote>
<p>目前此扩展的讨论基于 M/S/U 的三特权设计</p>
</blockquote>
<ul>
<li><a href="ch1_extN.html#%E7%94%A8%E6%88%B7%E6%80%81%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B">用户态中断与异常的执行流程</a>
<ul>
<li><a href="ch1_extN.html#%E4%B8%AD%E6%96%AD%E7%9A%84%E4%BA%A7%E7%94%9F">中断的产生</a></li>
<li><a href="ch1_extN.html#%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BA%A7%E7%94%9F">异常的产生</a></li>
<li><a href="ch1_extN.html#%E4%B8%AD%E6%96%AD%E7%9A%84%E5%A4%84%E7%90%86">中断的处理</a></li>
</ul>
</li>
<li><a href="ch1_extN.html#n-%E6%89%A9%E5%B1%95%E7%9A%84-csr">N 扩展的 CSR</a>
<ul>
<li><a href="ch1_extN.html#ustatus">ustatus</a></li>
<li><a href="ch1_extN.html#uip-uie">uip<code> </code>uie</a></li>
<li><a href="ch1_extN.html#sedeleg-sideleg">sedeleg<code> </code>sideleg</a></li>
<li><a href="ch1_extN.html#uscratch">uscratch</a></li>
<li><a href="ch1_extN.html#uepc">uepc</a></li>
<li><a href="ch1_extN.html#ucause">ucause</a></li>
<li><a href="ch1_extN.html#utvec">utvec</a></li>
<li><a href="ch1_extN.html#utval">utval</a></li>
</ul>
</li>
<li><a href="ch1_extN.html#n-%E6%89%A9%E5%B1%95%E7%9A%84%E6%8C%87%E4%BB%A4">N 扩展的指令</a>
<ul>
<li><a href="ch1_extN.html#uret">URET</a></li>
</ul>
</li>
</ul>
<h2 id="用户态中断与异常的执行流程"><a class="header" href="#用户态中断与异常的执行流程">用户态中断与异常的执行流程</a></h2>
<p><img src="assets/trap_flow.drawio.svg" alt="用户态中断与异常的执行流程" /></p>
<h3 id="中断的产生"><a class="header" href="#中断的产生">中断的产生</a></h3>
<p>与 M 态和 S 态类似，中断分为软件中断 (Software Interrupt)、时钟中断 (Timer Interrupt) 和外部中断 (External Interrupt)。</p>
<blockquote>
<p>之后为了方便，三类中断会简称为 xSI、xTI、xEI，其中 x 为特权级。</p>
</blockquote>
<p>当中断发生时，通过硬件机制设置 <code>uip</code> 寄存器中的 <code>UXIP</code> 位 (X 表示中断种类) 为 1。硬件检测发现 <code>uip</code> 非零，于是进入中断的判断流程。</p>
<p>首先，检查该中断是否被允许发生，即检查 <code>uie.UXIE</code> 是否为 1。如果为真，再检查该中断是否被委托给用户态处理，即检查 <code>sideleg</code> 寄存器中对应的位。如果仍为真，检查全局中断使能是否为真，即检查 <code>ustatus.UIE</code> 是否为 1。如果还为真，则触发中断处理的流程。</p>
<blockquote>
<p><strong>注意</strong></p>
<p>上述寄存器中，<code>uie</code> <code>uip</code> 为 <code>mie</code> <code>mip</code> 的子集，即读写会同时作用于所有的 <code>xip</code> <code>xie</code> 或它们本就是同一寄存器。而 <code>ustatus</code> 至少 <code>UIE</code> 和 <code>UPIE</code> 与 <code>mstatus</code> 中的相同位相同。</p>
<p>虽然上述中断产生的流程中有判断次序，实际实现中一般使用组合逻辑，将寄存器值进行位与来判断，可以认为是同时判断的。</p>
</blockquote>
<h3 id="异常的产生"><a class="header" href="#异常的产生">异常的产生</a></h3>
<p>当异常发生时，硬件只检查 <code>sedeleg</code> 寄存器中对应的位是否为 1，若为真则触发异常的处理流程。</p>
<p>在 RISC-V 中，中断和异常的处理流程是统一的，下面出于描述简单考虑，多数情况下围绕中断进行描述。</p>
<h3 id="中断的处理"><a class="header" href="#中断的处理">中断的处理</a></h3>
<p>在上述的产生流程后，处理器开始进行一些预处理：</p>
<ul>
<li>设置 <code>ustatus.UPIE</code> 为 <code>ustatus.UIE</code> 的值，并置 <code>ustatus.UIE</code> 为 0</li>
<li>根据中断类型设置 <code>ucause</code></li>
<li>设置 <code>uepc</code> 为发生中断或异常时的 <code>pc</code></li>
<li>(可选) 设置 <code>utval</code></li>
<li>根据 <code>utvec</code> 的最低二位和高位的基地址，跳转到设置好的中断处理程序</li>
</ul>
<p>中断处理程序需要完成以下工作：</p>
<ul>
<li>保存现场</li>
<li>如果 <code>utvec</code> 为 direct 模式，根据 <code>ucause</code> 执行相应的处理程序</li>
<li>如果 <code>utvec</code> 为 vector 模式，执行处理程序</li>
<li>恢复现场</li>
</ul>
<p>需要保存和恢复的现场有</p>
<ul>
<li>x1-x31 寄存器 (如果确定中断处理程序中不会使用到某些寄存器，可以省去保存和恢复)</li>
<li><code>ustatus</code> (可能需要通过修改 <code>ustatus</code> 来改变 CPU 状态)</li>
<li><code>uepc</code> (可能需要通过修改进一步触发 S 态的中断/异常)</li>
<li><strong>我们尚未注意到的但需要保存和恢复的寄存器</strong></li>
</ul>
<p><img src="assets/trap.drawio.svg" alt="中断与异常的硬件处理流程" /></p>
<h2 id="n-扩展的-csr"><a class="header" href="#n-扩展的-csr">N 扩展的 CSR</a></h2>
<blockquote>
<p>WPRI: 该段数值保留为以后使用，欲读取该位时得到合法的值，即 0</p>
</blockquote>
<h3 id="ustatus"><a class="header" href="#ustatus">ustatus</a></h3>
<pre><code>UXLEN-1 5   4    3  1    0
┌────────┬──────┬──────┬─────┐
│  WPRI  │ UPIE │ WPRI │ UIE │
└────────┴──────┴──────┴─────┘
  UXLEN-5   1       3     1
</code></pre>
<p><code>ustatus</code> 是一个 UXLEN 位长的读写寄存器，记录和控制硬件的工作状态。</p>
<p>用户态中断使能位 UIE 为零时阻止用户态中断的发生。为了向用户态陷入处理程序提供原子性， UIE 中的值在用户态中断被处理时复制到 UPIE 并被置为零。</p>
<p>UIE 和 UPIE 是 <code>mstatus</code> 和 <code>sstatus</code> 中对应位的镜像。在硬件实现中三者可以是同一寄存器。</p>
<p>指令 URET 用于从陷入状态返回用户态。URET 将 UPIE 复制回 UIE，然后将 UPIE 置位，最后将 <code>uepc</code> 拷贝至 <code>pc</code>。</p>
<p>用户态中断只能在用户态触发，所以不需要 UPP 位。</p>
<h3 id="uip-uie"><a class="header" href="#uip-uie">uip<code> </code>uie</a></h3>
<p><code>uip</code> 和 <code>uie</code> 均为 UXLEN 位的读写寄存器，其中 <code>uip</code> 存储等待处理的中断信息， <code>uie</code> 存储相应的中断使能位。</p>
<pre><code>| WPRI | UEIP | WPRI | UTIP | WPRI | USIP |

| WPRI | UEIE | WPRI | UTIE | WPRI | USIE |
</code></pre>
<p>定义三种中断：软件中断、时钟中断、外部中断。用户态软件中断通过置位当前的 hart 的 <code>uip</code> 的软件中断等待 (USIP) 来触发。清零该位可以取消等待中的软件中断。当 <code>uie</code> 中的 USIE 为零时，用户态软件中断被禁止。</p>
<p>ABI 应当提供一种向其他 hart 发送处理器间中断的机制，这最终将置位接收 hart 的 <code>uip</code> 寄存器的 USIP 位。</p>
<p>除了 USIP， <code>uip</code> 中的其他位在用户态是可读的。</p>
<p>如果 <code>uip</code> 寄存器中的 UTIP 位被置位，一个用户态定时器中断将进入待处理状态。当 <code>uie</code> 寄存器中的 UTIE 位被置零时，用户态定时器中断被禁用。ABI 应该提供一个机制来清除一个待定的定时器中断。</p>
<p>如果 <code>uip</code> 寄存器中的 UEIP 位被置位，一个用户态外部中断将进入待处理状态。当 <code>uie</code> 寄存器中的 UEIE 位被置位时，用户态外部中断被禁用。ABI 应该提供屏蔽、解除屏蔽和查询外部中断原因的机制。</p>
<p><code>uip</code> 和 <code>uie</code> 寄存器是 <code>mip</code> 和 <code>mie</code> 寄存器的子集。读取 <code>uip</code>/<code>uie</code> 的任何字段，或者写入任何可写字段，都会对 <code>mip</code>/<code>mie</code> 的相应字段进行读取或写入。如果系统实现了 S 模式，<code>uip</code> 和 <code>uie</code> 寄存器也是 <code>sip</code> 和 <code>sie</code> 寄存器的子集。</p>
<h3 id="sedeleg-sideleg"><a class="header" href="#sedeleg-sideleg">sedeleg<code> </code>sideleg</a></h3>
<p>为提升中断和异常的处理性能，可以实现独立的读写寄存器 <code>sedeleg</code> 和 <code>sideleg</code>，设置其中的位将特定的中断和异常交由用户态陷入处理程序处理。</p>
<p>当一个陷入被委托给一个权限较低的模式 u 时，<code>ucause</code> 寄存器被写入陷阱的原因；<code>uepc</code> 寄存器被写入发生陷阱的指令的虚拟地址；<code>utval</code> 寄存器被写入一个特定的异常数据；<code>mstatus</code> 的 UPIE 字段被写入陷阱发生时 UIE 字段的值；<code>mstatus</code> 的 UIE 字段被清零。<code>mcause</code>/<code>scause</code> 和 <code>mepc</code>/<code>sepc</code> 寄存器以及 <code>mstatus</code> 的 MPP 和 MPIE 字段不被写入。</p>
<p>一个实现不应硬性规定任何委托位为一，也就是说，任何可以被委托的陷阱都必须支持不被委托。一个实现方案是选择可委托的陷入的子集。支持的可委托位可通过向每个比特位置写 1，然后读回 <code>medeleg</code>/<code>sedeleg</code> 或 <code>mideleg</code>/<code>sideleg</code> 中的值，看看哪些位上有 1。</p>
<blockquote>
<p>目前，不支持触发低权限级的陷入</p>
</blockquote>
<p>不会在用户态发生的应硬件恒零，如 ECall from S/H/M-mode</p>
<h3 id="uscratch"><a class="header" href="#uscratch">uscratch</a></h3>
<p><code>uscratch</code> 寄存器是一个 UXLEN 位读/写寄存器。</p>
<h3 id="uepc"><a class="header" href="#uepc">uepc</a></h3>
<p><code>uepc</code> 是 UXLEN 位读写寄存器。最低位（<code>uepc[0]</code>）恒零。次低位 <code>uepc[1]</code> 视实现的对齐需求而定。</p>
<p><code>uepc</code> 是 WARL 寄存器，应能存储所有的合法物理/虚拟地址，但不需要能挣钱存储非法地址。实现可以先将非法地址转为其他非法地址再写入 <code>uepc</code>。</p>
<p>但陷入在用户态处理时，<code>uepc</code> 被写入中断或触发异常的指令的虚拟地址。此外，除了软件显式地写，否则 <code>uepc</code> 应永不被写。</p>
<h3 id="ucause"><a class="header" href="#ucause">ucause</a></h3>
<pre><code>| Interrupt | Exception Code WLRL |
</code></pre>
<p><code>ucause</code> 是 UXLEN 位长读写寄存器。</p>
<h3 id="utvec"><a class="header" href="#utvec">utvec</a></h3>
<pre><code>| BASE[UXLEN-1 : 2] | MODE |
</code></pre>
<p><code>utvec</code> 是 UXLEN 位长读写寄存器，存储陷入向量，包括向量基地址和向量模式。</p>
<p>BASE 是 WARL，可以存储任意合法的虚拟地址或物理地址，需要 4 字节对齐。特殊的模式可以有其他对齐标准。</p>
<table><thead><tr><th>value</th><th>name</th><th>description</th></tr></thead><tbody>
<tr><td>0</td><td>direct</td><td>base</td></tr>
<tr><td>1</td><td>vectored</td><td>base + 4 * cause</td></tr>
<tr><td></td><td></td><td>reserved</td></tr>
</tbody></table>
<h3 id="utval"><a class="header" href="#utval">utval</a></h3>
<p>存储内容仍在讨论中</p>
<h2 id="n-扩展的指令"><a class="header" href="#n-扩展的指令">N 扩展的指令</a></h2>
<h3 id="uret"><a class="header" href="#uret">URET</a></h3>
<p><code>uret</code> 将 <code>pc</code> 设置为 <code>uepc</code> ，将 <code>ustatus.UIE</code> 设置为 <code>ustatus.UPIE</code> ，从而恢复中断前的状态。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="用户态中断的使用"><a class="header" href="#用户态中断的使用">用户态中断的使用</a></h1>
<blockquote>
<p>本节描述构想中的用户态中断的使用，部分功能细节仍在进一步讨论中</p>
</blockquote>
<h2 id="需要解决的问题"><a class="header" href="#需要解决的问题">需要解决的问题</a></h2>
<p>在一个成熟的操作系统中，同时运行的用户态进程数量是十分庞大的。在传统的实现方案中，这些用户态进程互相之间通信或与外设通信都需要经过内核态，这造成了大量的页表切换等颇具开销的行为。如果可以让用户态进程自己处理不需要内核态权限的中断，应能减少相应的开销，使得操作系统的性能得到提升。</p>
<p>此外，许多需要用户态进程处理的中断并不需要即时处理，引入用户态中断的机制可以在用户态进程被调度的时候再触发，减少对执行情况的干扰。</p>
<h2 id="陷入信息表"><a class="header" href="#陷入信息表">陷入信息表</a></h2>
<p>为解决用户态进程数量过多且不同用户态进程有不同的用户态中断处理程序和中断信息，需添加进程的“陷入信息表” (Trap Information Table, TIT)。其结构和进程控制块的关系如下图：</p>
<p><img src="assets/TIT.drawio.svg" alt="trap info table" /></p>
<p>内核态维护一个先入先出的“陷入信息队列”，当有新的陷入信息时，将其添加至队列的尾部；而在用户态进程被调度时，内核态检查发现有陷入信息时，将相应信息恢复至寄存器，并设置 <code>uip</code> 寄存器。在返回至用户态后，立即触发中断，进入用户态进程自己设定的用户态中断处理程序。</p>
<p><code>utval</code> 寄存器存储中断的具体信息，其结构为：</p>
<pre><code>+-----+------+-----------+
| TAG | TYPE | trap info |
+-----+------+-----------+
</code></pre>
<p><code>TAG</code> 用于记录中断是传递给哪个进程，<code>TYPE</code> 用于进一步区分中断的类别，<code>trap info</code> 则存储中断的更为详细的信息。</p>
<h2 id="中断的响应"><a class="header" href="#中断的响应">中断的响应</a></h2>
<h3 id="即时的中断响应"><a class="header" href="#即时的中断响应">即时的中断响应</a></h3>
<p>用户态可能接收到并即时处理的中断有时钟中断、外部中断以及自行设置的软件中断。当中断发生时，会执行以下步骤：</p>
<ol start="0">
<li>硬件设置用户态寄存器。</li>
<li>检查将要写入 <code>utval</code> 的值中的 <code>TAG</code> 是否为当前正在运行的进程。如果是，触发用户态中断，执行与恢复；如果不是，触发 S 态中断。</li>
<li>进入 S 态中断，根据 <code>TAG</code> 将用户态 CSR 中的值存储在对应进程的 <code>TIT</code> 中，恢复并继续执行原用户态进程。该中断转为另一进程的“非即时中断”。</li>
</ol>
<h3 id="非即时的中断响应"><a class="header" href="#非即时的中断响应">非即时的中断响应</a></h3>
<p>一个进程存在非即时的中断需要响应，即在被调度时其 <code>TIT</code> 非空。操作系统依序执行以下步骤：</p>
<ol start="0">
<li>欲调度该进程，检查 <code>TIT</code> ，发现存在需要处理的陷入信息。</li>
<li>内核态构造 <code>trap frame</code> ，将 <code>trap info</code> 中的 <code>ucause</code> 和 <code>utval</code> 放入 <code>trap frame</code> 中，并设置 <code>uip</code> 中对应位，设置 <code>ustatus.UPIE</code>。使用 <code>uret</code> 返回用户态</li>
<li><code>uret</code> 根据 <code>utatus.UPIE</code> 设置 <code>ustatus.UIE</code> ，用户态中断全局使能被开启。</li>
<li>触发用户态中断，进入 <code>utvec</code> 对应的用户态中断处理程序，保存现场。</li>
<li>查看 <code>ucause</code> 和 <code>utval</code> ，选择对应的处理分支。</li>
<li>处理完成后，恢复现场，恢复用户态进程的运行。</li>
</ol>
<h2 id="应用示例"><a class="header" href="#应用示例">应用示例</a></h2>
<h3 id="跨进程信号示例"><a class="header" href="#跨进程信号示例">跨进程“信号”示例</a></h3>
<p>假设在一个单核、支持 N 扩展的 CPU 上运行一支持用户态中断的操作系统，有进程 A 和进程 B，且有某种机制使它们互相知道彼此的 <code>pid</code>。</p>
<ol>
<li>进程 A 执行 <code>ecall</code> ，触发内核态中断，并通过寄存器 <code>a0-a7</code> 传递参数：跨进程信号，发送目标 B，传递信息 <code>0x1</code>。</li>
<li>进入内核态中断处理程序 <code>ecall</code> 分支，根据寄存器值判断为“跨进程信号”，开始构造 B 的 <code>trap info</code>：
<ul>
<li>构造 <code>utval</code>：<code>| TAG::B_pid | TYPE::cross_process_signal | trap_info ( src_pid: A_pid, info: 0x1 ) |</code></li>
<li>构造 <code>uip</code>：<code>| 0x0 | USIP ( 1 ) | 0x0 |</code> (挂起用户态软件中断)</li>
<li>构造 <code>ucause</code>: <code>0x8000_0000_0000_0000</code> (用户态软件中断)</li>
</ul>
</li>
<li>将 <code>trap info</code> 存入 B 的 <code>TIT</code>，恢复 A 的运行。</li>
<li>时间片轮转或 A 主动让权，开始调度 B。</li>
<li>内核态检查 <code>TIT</code> 非空，开始构建 <code>trap frame</code>：
<ul>
<li>根据 <code>PCB</code> 中的 <code>Trap Context</code> ，设置寄存器 <code>x1-x31</code> <code>utvec</code> <code>uie</code> <code>ustatus</code> <code>uepc</code></li>
<li>从 <code>PCB</code> 指向的 <code>TIT</code> 取出第一个 <code>trap info</code> ，根据内容设置寄存器 <code>utval</code> <code>uip</code> <code>ucause</code></li>
</ul>
</li>
<li>使用 <code>uret</code> 恢复进入用户态：
<ul>
<li>通过 <code>pc = uepc</code> 恢复为上次运行时间片最后的 <code>pc</code></li>
<li>通过 <code>ustatus.UIE = ustatus.UPIE</code> 开启用户态中断全局使能，允许中断发生</li>
</ul>
</li>
<li>中断发生，跳转 <code>utvec</code> 对应的用户态中断处理程序，保存现场。</li>
<li>通过查看 <code>utval</code> 和 <code>ucause</code> 知道是来自 A 的跨进程信号，进入相应分支处理。</li>
<li>处理完毕，恢复现场，继续执行 B 进程。</li>
</ol>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="操作系统-1"><a class="header" href="#操作系统-1">操作系统</a></h1>
<p>我们选择基于 <a href="https://github.com/TianhuaTao/uCore-SMP/tree/label-riscv">TianhuaTao/uCore-SMP</a> 和 rCore，加入用户态中断和标签的支持，完成软硬件的协同。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="操作系统标签化-ucore-smp"><a class="header" href="#操作系统标签化-ucore-smp">操作系统：标签化 uCore-SMP</a></h1>
<p>uCore-SMP 在设计时目标平台为 QEMU ，将其移植到 FPGA 平台主要需要解决如下问题：内存布局、时钟周期、页表项属性和硬盘外设。移植完成后，还需添加对标签系统的支持。代码仓库位于 https://github.com/TianhuaTao/uCore-SMP/tree/label-riscv 。</p>
<h2 id="内存布局"><a class="header" href="#内存布局">内存布局</a></h2>
<p>QEMU 中内存的起始地址为 0x80000000 ，而 FPGA 平台起始地址为 0x100000000 ，相应的内核启动地址也要调整到 0x100200000 ，这两个值需要在 <code>memory_layout.h</code> 和 <code>kernelld.py</code> 中进行修改。QEMU 中配置总内存空间为 128MB，而尽管 FPGA 平台有 2GB DRAM，由于内存带宽有限，uCore-SMP 在启动时又会将所有内存地址遍历并初始化。为了减少操作系统的启动等待时间，综合考虑内核和用户程序所需的内存空间，最终将可分配的内存限制在 32MB 。</p>
<h2 id="时钟周期"><a class="header" href="#时钟周期">时钟周期</a></h2>
<p>QEMU 中 CPU 运行频率（即 <code>cycle</code> 寄存器的增加频率）为 3GHz ，而实时时钟（RTC）频率（即 <code>time</code> 寄存器的增加频率）为 12.5MHz ；FPGA 平台上 CPU 频率为 100MHz ，RTC 频率为 10MHz，需要在 <code>timer.h</code> 中修改。</p>
<h2 id="页表项属性"><a class="header" href="#页表项属性">页表项属性</a></h2>
<p>根据 RISC-V 规范中虚拟内存章节的描述，页表项中有“已访问（A）”和“已修改（D）”两个标志位，对这两个标志位，规范允许两种处理方式：</p>
<blockquote>
<ul>
<li>When a virtual page is accessed and the A bit is clear, or is written and the D bit is clear, a page-fault exception is raised.</li>
<li>When a virtual page is accessed and the A bit is clear, or is written and the D bit is clear, the implementation sets the corresponding bit(s) in the PTE. The PTE update must be atomic with respect to other accesses to the PTE, and must atomically check that the PTE is valid and grants sufficient permissions. The PTE update must be exact (i.e., not speculative), and observed in program order by the local hart. Furthermore, the PTE update must appear in the global memory order no later than the explicit memory access, or any subsequent explicit memory access to that virtual page by the local hart. The ordering on loads and stores provided by FENCE instructions and the acquire/release bits on atomic instructions also orders the PTE updates associated with those loads and stores as observed by remote harts.</li>
</ul>
</blockquote>
<p>即直接触发页错误异常，或由硬件实现直接对页表项置位。FPGA 平台实现为前一种，而 QEMU 为后一种。这两个标志位主要应用于虚拟存储系统中的页面置换，而 uCore-SMP 中对此并无支持，简单起见，可修改 <code>virtual.c</code> ，在分配新的页表项并映射物理页时，直接将 A 和 D 置位。</p>
<h2 id="硬盘外设"><a class="header" href="#硬盘外设">硬盘外设</a></h2>
<p>QEMU 中通过 virtio 提供了虚拟块存储设备，FPGA 平台中没有。在此情况下，为了仍然能够使用文件系统，陶天骅同学提供了虚拟磁盘接口和 ramdisk 功能，通过宏开关在编译期进行切换。系统初始化时， ramdisk 将在内存中开辟一块区域，并将其按照 nfs 格式进行初始化。</p>
<h2 id="标签系统"><a class="header" href="#标签系统">标签系统</a></h2>
<p>在内核初始化时，将标签系统控制平面基址以恒等映射挂载到 0x20000 地址处，权限为内核可读写。读取和写入参数的方式为基址+偏移，偏移量单位为 32bit ，即需要将地址强制转换为指向 32 位无符号整数的指针类型。具体各参数的偏移量和写入方法见 <code>dsid.c/h</code> 。</p>
<p>目前该系统支持至多 8 个不同的进程标签。进程标签存储于进程控制块中，在程序上下文切换时，内核将标签写入相应的 CSR 。内核的进程标签硬编码为 0 。</p>
<p>内核提供三个和标签相关的系统调用：</p>
<pre><code class="language-c">int set_dsid(int pid, uint32 dsid);
int set_dsid_param(uint32 dsid, uint32 freq, uint32 size, uint32 inc, uint32 mask);
uint32 get_l2_traffic(uint32 dsid);
</code></pre>
<ul>
<li><code>set_dsid</code> 将 <code>pid</code> 对应进程的标签设为 <code>dsid</code> ，若进程不存在，则返回 -1 ，否则返回 0 ；</li>
<li><code>set_dsid_param</code> 设置 <code>dsid</code> 标签相应的令牌桶参数和缓存掩码，参数含义见<a href="ch2_uCore.html#%E7%A1%AC%E4%BB%B6">“硬件”章节</a>。只有非零的参数会被写入控制平面。</li>
<li><code>get_l2_traffic</code> 读取 <code>dsid</code> 标签对应的 L1 和 L2 缓存之间的数据流量，单位为 64bit 。</li>
</ul>
<h2 id="与内核共同调试和-debug"><a class="header" href="#与内核共同调试和-debug">与内核共同调试和 debug</a></h2>
<p>标签系统开发过程中，主要查出内核中以下几个缺陷。</p>
<h3 id="调度器初值"><a class="header" href="#调度器初值">调度器初值</a></h3>
<p>uCore-SMP 使用 stride 算法进行调度，在初始实现中，fork 产生的子进程的 stride 会置为 0 。在使用标签系统监测负载程序的缓存性能时，设置父进程每隔一秒输出一次信息。第一批负载表现正常，但启动第二波负载时，会出现直到负载运行结束父进程才会输出的情况。分析后发现，由于子进程 stride 为 0 ，而运行第二波负载时，父进程已有一定的 stride ，此时调度器会持续优先调度子进程，导致父进程陷入“饥饿”。解决方法为，将子进程的 stride 置为和父进程相同。</p>
<h3 id="子进程回收内存泄露"><a class="header" href="#子进程回收内存泄露">子进程回收内存泄露</a></h3>
<p>初始实现中，若父进程没有使用 wait/waitpid 等待子进程结束，则子进程占用的内存和文件等资源在进程结束后不会被回收，当大量 fork 时会耗尽系统内存。为此，陶天骅同学在内核中加入了 reparent 机制，当进程退出时会检查其子进程，若子进程已退出则回收，否则将其父进程置为 NULL ；若退出的进程父进程为 NULL ，则立即回收自身占用的资源，这样解决了这一内存泄露问题。</p>
<h3 id="syscall-中的悬垂指针"><a class="header" href="#syscall-中的悬垂指针">syscall 中的悬垂指针</a></h3>
<p>系统调用进入内核中 syscall 函数时，会保存进程的 trapframe 地址，在具体系统调用执行完成后，使用该地址中的 a0 寄存器保存系统调用的返回值。在运行标签负载时发现，当用户程序运行到 0x1070 地址（用户态下的虚拟地址）时会触发非法指令异常，stval 寄存器显示相应的指令值为 0 ，但查看相应程序的反汇编发现此处并非 0 。起初怀疑是固件中非对齐 load/store 模拟存在问题，导致加载用户程序时出现数据异常；尽管发现固件确实存在问题，但解决该问题后依然会触发非法指令异常。</p>
<p>后来使用内核中 pushtrace 工具在各处记录 0x1070 对应内存地址的数值发现，当执行 execv 系统调用时，会回收原有的 trapframe 内存页，该页可能被后续用于加载用户程序的代码段，程序分配的新 trapframe 的 a0 和 a1 寄存器会分别用于存储 <code>argc</code> 和 <code>argv</code> ；但 execv 执行完成返回 syscall 函数中时（其返回值总为 0 ），仍会使用旧的 trapframe 地址，而 a0 寄存器对应变量在 trapframe 中相应的偏移量即为 0x70 ，向其中写入 0 会破坏用户程序代码，导致错误。解决方法为，当系统调用为 execv 时，在 syscall 函数中不写入 <code>trapframe-&gt;a0</code> 。</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="应用程序-1"><a class="header" href="#应用程序-1">应用程序</a></h1>
<p>为了使用标签系统，测量和展示标签系统的控制效果，设计了以下几个用户态应用程序：sort、jammer、prime、monitor、dsid_demo。</p>
<h2 id="sort"><a class="header" href="#sort">sort</a></h2>
<p>对 501202 个 32 位无符号整数，使用基数排序法进行排序，基为 65536 ，数据使用随机数生成器和固定的种子生成，并使用 sharedmem 作为动态申请内存的方式。每个进程会将自己的 pid 加入共享内存名字中，以确保多个负载不会申请到同一块共享内存。程序将自身的运行时间作为返回值，单位是毫秒。</p>
<p>这是一个内存密集型负载，消耗约 4.5MB 内存空间和 8MB/s 的内存带宽。</p>
<h2 id="prime"><a class="header" href="#prime">prime</a></h2>
<p>计算 2 到 52021 之间质数的个数。使用朴素算法，对于每个数 x ，枚举 2 到 x/2 之间的数，判断是否能够整除 x，若能，则 x 不是质数。这是一个计算密集型负载，可以用于验证多核正常运行，且运行时间几乎不受内存带宽限制的影响。</p>
<h2 id="jammer"><a class="header" href="#jammer">jammer</a></h2>
<p>这是一个干扰负载，在一个有 524288 个 32 位无符号整数的数组上随机进行读写，消耗内存带宽。申请内存的方式与 sort 程序相同，消耗约 2MB 内存空间和 8MB/s 的内存带宽。</p>
<h2 id="monitor"><a class="header" href="#monitor">monitor</a></h2>
<p>一个监测系统资源使用状况的程序，监测的资源包括 CPU 使用率、可用内存空间、各进程的运行时间、状态和内存占用、各标签的 L1 和 L2 之间的流量。每隔一秒输出一次，运行十秒后退出。其中 CPU 、内存和进程使用设备文件抽象接口，标签流量使用 <code>get_l2_traffic</code> 系统调用。运行界面如下：</p>
<p><img src="monitor.png" alt="m" /></p>
<h2 id="dsid_demo"><a class="header" href="#dsid_demo">dsid_demo</a></h2>
<p>本程序中内置了若干组令牌桶和缓存掩码参数用于分配给指定的负载，并执行 <code>monitor</code> 程序监测系统资源的使用情况。</p>
<p>使用方法为 <code>dsid_demo app1 param1 [app2 param2 [app3 param3]]</code> ，最多同时启动 3 个负载。例如， <code>dsid_demo sort 2 prime 1</code> 将为 <code>sort</code> 进程分配 2 号参数组，为 <code>prime</code> 进程分配 1 号参数组。由于可用的标签数量有限，同时为了方便监测起见，标签并不与参数组一一对应，而是为每个负载分配不同的标签，<code>appX</code> 的标签编号即为 X 。在上例中， <code>sort</code> 进程标签为 1 ，而 <code>prime</code> 进程标签为 2 。</p>
<p>各组参数具体的设计，是为了实现以下四种测试场景：</p>
<ul>
<li>不调控</li>
<li>内存带宽 5M：5M，缓存 768K：768K</li>
<li>内存带宽 7M：2M，缓存 1280K：256K</li>
<li>内存带宽 8M：1M，缓存 1280K：256K</li>
</ul>
<p>内置参数组如下（其中 size 参数值均为 0x800）：</p>
<table><thead><tr><th align="center">编号</th><th align="center">freq</th><th align="center">inc</th><th align="center">cache mask</th><th>备注</th></tr></thead><tbody>
<tr><td align="center">0</td><td align="center">10000</td><td align="center">40</td><td align="center">0x000F</td><td>用于内核进程和监测程序，内存带宽约 3MB/s ，<br/>缓存 512K，与其他参数组隔离</td></tr>
<tr><td align="center">1</td><td align="center">100</td><td align="center">100</td><td align="center">0xFFF0</td><td>内存带宽不限，缓存 1536K</td></tr>
<tr><td align="center">2</td><td align="center">7800</td><td align="center">80</td><td align="center">0xFFC0</td><td>内存带宽约 8MB/s ，缓存 1280K</td></tr>
<tr><td align="center">3</td><td align="center">7800</td><td align="center">10</td><td align="center">0x0030</td><td>内存带宽约 1MB/s ，缓存 256K</td></tr>
<tr><td align="center">4</td><td align="center">7800</td><td align="center">80</td><td align="center">0xFFF0</td><td>内存带宽约 8MB/s ，缓存 1536K</td></tr>
<tr><td align="center">5</td><td align="center">7800</td><td align="center">10</td><td align="center">0xFFF0</td><td>内存带宽约 1MB/s ，缓存 1536K</td></tr>
<tr><td align="center">6</td><td align="center">100</td><td align="center">100</td><td align="center">0xFFC0</td><td>内存带宽不限，缓存 1280K</td></tr>
<tr><td align="center">7</td><td align="center">100</td><td align="center">100</td><td align="center">0x0030</td><td>内存带宽不限，缓存 256K</td></tr>
<tr><td align="center">8</td><td align="center">9300</td><td align="center">60</td><td align="center">0x03F0</td><td>内存带宽约 5MB/s ，缓存 768K</td></tr>
<tr><td align="center">9</td><td align="center">9300</td><td align="center">60</td><td align="center">0xFC00</td><td>内存带宽约 5MB/s ，缓存 768K</td></tr>
<tr><td align="center">10</td><td align="center">9300</td><td align="center">60</td><td align="center">0xFFF0</td><td>内存带宽约 5MB/s ，缓存 1536K</td></tr>
<tr><td align="center">11</td><td align="center">100</td><td align="center">100</td><td align="center">0x03F0</td><td>内存带宽不限，缓存 768K</td></tr>
<tr><td align="center">12</td><td align="center">100</td><td align="center">100</td><td align="center">0xFC00</td><td>内存带宽不限，缓存 768K</td></tr>
<tr><td align="center">13</td><td align="center">7800</td><td align="center">70</td><td align="center">0xFFC0</td><td>内存带宽约 7MB/s ，缓存 1280K</td></tr>
<tr><td align="center">14</td><td align="center">7800</td><td align="center">20</td><td align="center">0x0030</td><td>内存带宽约 2MB/s ，缓存 256K</td></tr>
<tr><td align="center">15</td><td align="center">7800</td><td align="center">70</td><td align="center">0xFFF0</td><td>内存带宽约 7MB/s ，缓存 1536K</td></tr>
<tr><td align="center">16</td><td align="center">7800</td><td align="center">20</td><td align="center">0xFFF0</td><td>内存带宽约 2MB/s ，缓存 1536K</td></tr>
</tbody></table>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="成果示例"><a class="header" href="#成果示例">成果示例</a></h1>
<h2 id="标签-risc-v-cpu-与-标签化-ucore-smp"><a class="header" href="#标签-risc-v-cpu-与-标签化-ucore-smp">标签 RISC-V CPU 与 标签化 uCore-SMP</a></h2>
<p>FPGA 平台内存带宽约 12MB/s ，测试场景如 <a href="ch4_example.html#dsid_demo">“dsid_demo”章节</a> 中所述。测试结果如下：</p>
<p>可见在存在干扰情况下，给排序程序分配内存带宽越多，其性能越接近不受干扰时的情形，显示出内存带宽调控的效果；当内存带宽 7:2 分配时，控制缓存性能较优，而 8:1 分配时，不控制缓存缓存性能较优，这可能是因为缓存的分配比例介于二者之间，8:1 分配时，若不控制缓存，排序程序对缓存的利用率可以高于 7:2 时。</p>
<h3 id="后续优化方向"><a class="header" href="#后续优化方向">后续优化方向</a></h3>
<ol>
<li>自动和闭环控制：将应用的服务质量需求描述自动转换为标签系统的控制参数，并不断监测调节，提高灵活性、准确性和鲁棒性；</li>
<li>延迟控制：增加对应用服务延迟的测量和监测机制，展示标签系统控制延迟波动、提高用户体验的功能；</li>
<li>适配更多资源和场景：如图形计算的算力和存储、分布式系统中跨结点的标签传递、嵌入式平台中的实时性保证；</li>
<li>更多启动器功能：添加 Remote Fence、Hart 状态管理等 SBI 扩展，为操作系统提供更完善的支持。</li>
</ol>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="参考"><a class="header" href="#参考">参考</a></h1>
<ul>
<li><a href="https://github.com/riscv/riscv-isa-manual">RISC-V Instruction Set Manual</a></li>
<li><a href="https://man7.org/linux/man-pages/man7/cgroups.7.html">cgroups(7) — Linux manual page</a></li>
<li><a href="https://www.intel.cn/content/www/cn/zh/architecture-and-technology/resource-director-technology.html">英特尔 ® 资源调配技术 (英特尔 ® RDT)</a></li>
<li><a href="https://developer.arm.com/documentation/ddi0598/latest">Arm Architecture Reference Manual Supplement Memory System Resource Partitioning and Monitoring (MPAM), for Armv8-A</a></li>
<li><a href="https://carrv.github.io/2017/papers/yu-labeled_riscv-carrv2017.pdf">Labeled RISC-V: A New Perspective on Software-Defined Architecture</a></li>
<li><a href="https://github.com/TianhuaTao/uCore-SMP/">uCore-SMP GitHub 仓库</a></li>
<li><a href="https://github.com/LvNA-system/labeled-RISC-V/tree/master/fpga">labeled-RISC-V GitHub 仓库</a></li>
<li><a href="https://www.xilinx.com/products/boards-and-kits/ek-u1-zcu102-g.html">Zynq UltraScale+ MPSoC ZCU102 Evaluation Kit</a></li>
<li><a href="https://github.com/chipsalliance/rocket-chip">Rocket Chip Generator</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/164503398">令牌桶工作原理</a></li>
<li><a href="https://github.com/luojia65/rustsbi/tree/master/platform/qemu">RustSBI GitHub 仓库</a></li>
<li><a href="https://www.xilinx.com/support/documentation/ip_documentation/axi_uartlite/v2_0/pg142-axi-uartlite.pdf">AXI UART Lite v2.0 LogiCORE IP Product Guide</a></li>
<li><a href="https://five-embeddev.com/riscv-isa-manual/latest/supervisor.html#sec:translation">RISC-V Page-Based Virtual-Memory Systems</a></li>
<li><a href="https://github.com/Gallium70/labeled-RISC-V-reproduction-note">在 FPGA 上复现标签化 RISC-V 架构——踩坑指南</a></li>
<li><a href="https://github.com/Gallium70/lrv-rust-bl">Labeled RISC-V Rust Bootloader GitHub 仓库</a></li>
<li><a href="https://github.com/TianhuaTao/uCore-SMP/tree/label-riscv">标签化 uCore-SMP GitHub 仓库</a></li>
<li><a href="https://github.com/Gallium70/labeled-RISC-V-boot">labeled-RISC-V-boot GitHub 仓库</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
