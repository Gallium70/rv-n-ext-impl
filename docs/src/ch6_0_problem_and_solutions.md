# 遇到的主要问题与解决方法

## 多核改造中的死锁问题

在 rCore-N 的改造中，遇到了一个死锁问题：

进程 1 在退出时，内核获取 1 的锁来访问它的信息，同时要获取 0 号进程的锁，将进程 1 的子进程放到 0 号进程的子进程列表中，以避免资源不能正确地释放。同时，0 号进程会调用 `wait_pid` 系统调用，查看自己的子进程是否有运行结束的，来释放资源。而在 `wait_pid` 中，会需要获取调用者（0 号进程）与目标进程的锁，来访问它们的信息。

在单核环境下，由于上述两种过程都发生于内核态，且不允许嵌套中断，便不会发生死锁问题。而在多核环境下，0 号进程运行在一个核上，调用 `wait_pid` 去查看子进程 1 号；1 号进程运行在另一个核上，正在退出。这时就很有可能分别持有 0 号和 1 号的锁，要拿另一方的锁来查看或更改信息，从而进入死锁状态。

我们采用加一个大锁的方式来解决此问题，即当一段程序需要获取多个进程的锁时，需要先尝试获取大锁。在获取了大锁之后才会进入获取多个进程的锁的程序，避免了上述多段程序同时需要获取多个进程的锁的问题。

具体到代码上，简略后如下：

```rust
pub fn sys_waitpid(pid: isize, exit_code_ptr: *mut i32) -> isize {
    // 获取大锁
    let _ = WAIT_LOCK.lock();
    // 获取当前进程的锁
    ...
    // 遍历子进程，获取锁来读取状态
    ...
}

pub fn exit_current_and_run_next(exit_code: i32) {
    // 获取大锁
    let wl = WAIT_LOCK.lock();
    // 获取要退出进程的锁
    ...
    // 获取 0 号进程的锁
    ...
    // 释放所有锁
    drop(wl);
    ...
}
```
