# 跨核中断控制器设计

本节描述用于直接发送跨核用户态中断的中断控制器。当发送方用户进程和接收方用户进程都在运行时，此中断控制器可以将用户态中断直接发送到接收方。

中断控制器采用内存映射的接口。设计方案允许用户进程发送中断时指定接收方、接收中断时获知发送方，允许操作系统管理用户态中断的发送。

简洁起见，下文中若不加特殊说明，所有提及的中断都指用户态软件中断。

## 简介

中断控制器为一系列硬件线程提供中断发送和接收功能。中断控制器中，涉及到的每个硬件线程从 0 开始依次编号，此编号可以与对应硬件线程的 Hart ID（`mhartid`）相同或不同。在下文介绍中，我们设 `n` 为涉及的硬件线程是数量，所以编号的范围为 `0` 到 `n - 1`。每个硬件线程可以作为中断的发送方和接收方，在中断控制器中均以其编号表示。`n` 的最大值为 4095。

每个用户进程应被分配一个用户态中断 ID，下称 UIID（User Interrupt ID）。UIID 和操作系统内的进程 ID 可以相同或不同。

除了硬件线程上运行的用户进程之间的中断发送，中断控制器为可能不在运行的接收方进程提供中断缓冲区，用户进程可以向缓冲区发送中断，由操作系统读取并分发。缓冲区中每一项包括发送方和接收方的 UIID。

下面简要介绍中断控制器提供的寄存器。若不加特殊说明，下文所有寄存器均为 32 位，在内存中占 4 字节。不同寄存器读写时实际有意义的位数可能各异。

对于每对发送方硬件线程和接收方硬件线程，中断控制器提供以下寄存器用于中断整体管理：

- **使能寄存器 enable**

  一位，记录发送方是否可以向接收方发送中断。

  此寄存器意指由操作系统读写。

  下用 `enable[s][r]` 表示 `s` 发送中断给 `r` 的使能，`1` 表示允许发送，`0` 表示禁止发送。

  为了操作便捷，使能寄存器在内存映射中压位，并可以分别根据发送方或接收方编号连续访问。对于每个发送方，连续 32 个接收方的使能会占一个 4 对齐的内存地址，此地址的每一位分别表示一个接收方的使能寄存器值。对于每个接收方，连续 32 个发送方给的使能会占一个 4 对齐的内存地址，此地址的每一位分别表示一个发送方的使能寄存器值。

  对于 RV64，允许一次访问 8 字节，提高的操作效率。

- **等待寄存器 pending**

  一位，记录发送方是否已向接收方发送中断，此中断尚未被接收方领取或发送方撤回。

  此寄存器不提供内存映射接口，仅能被间接控制。

  下用 `pending[s][r]` 表示是否有 `s` 向 `r` 发送的正在等待的中断，`1` 表示有`0` 表示没有。

对于每个硬件线程，中断控制器提供以下寄存器用于记录运行的用户进程编号：

- **UIID 寄存器 uiid**

  用于记录发送方用户进程的 UIID。

  此寄存器意指让操作系统维护用户态中断发送和接收方的 UIID。

  下用 `uiid[i]` 表示硬件线程 `i` 对应的 UIID 寄存器。

对于每个硬件线程，中断控制器提供以下寄存器用于发送和发送管理：

- **发送寄存器 send**

  向此寄存器写入接收方的 UIID 以请求向后者发送用户态中断。

  下用 `send[s]` 表示发送方 `s` 对应的发送寄存器。

- **发送状态寄存器 status**

  从此寄存器读取检查上一次发送是否成功。

  下用 `status[s]` 表示发送方 `s` 对应的发送状态寄存器。

- **撤回寄存器 withdraw**

  读取此寄存器可以得到此硬件线程已发送且尚未被领取的中断接收方 UIID 之一。向读取到的接收方硬件线程发送的中断被撤回。

  此寄存器意指由操作系统撤回时间片结束的用户进程已发送的中断。

对于每个硬件线程，中断控制器提供以下寄存器用于接收和接收管理：

- **领取寄存器 claim**

  读取此寄存器可以得到发送给此硬件线程的中断发送方 UIID 之一。读取到的发送方硬件线程发送的中断被领取。

- **接收屏蔽寄存器 recv_disable**

  此寄存器仅有最低位有效，向其写入 `0` 立刻屏蔽所有发送方向此硬件线程发送的中断。

  读取此寄存器所得值无效，应被忽略。

  此寄存器意指由操作系统在用户进程时间片结束时，屏蔽此硬件线程的中断接收。

整个中断控制器提供如下寄存器：

- **缓冲区出队发送方 UIID 寄存器 fifo_pop_send**

  读取此寄存器获取向缓冲区发送寄存器发送中断的发送方 UIID。

- **缓冲区出队接收方 UIID 寄存器 fifo_pop_recv**

  读取此寄存器获取向缓冲区发送寄存器发送中断的接收方 UIID。

上述寄存器读写的详细效果见下文。

## 内存映射

中断控制器采用内存映射，其基址由实现定义。各寄存器相对于基址的偏移见下。

> 0x0000000 - 0x0FFEFFC 的部分每个 4 KiB 页是每个硬件线程的**发送寄存器 send**、**状态寄存器 send / status** 和**领取寄存器 claim**，意指让操作系统映射给用户进程。
>
> 0x1000000 - 0x1FFEFFC 的部分每个 4 KiB 页是每个硬件线程的其余寄存器，意指由操作系统管理。

| 偏移                  | 寄存器描述                                                           |
| --------------------- | -------------------------------------------------------------------- |
| 0x0000000             | 0 号硬件线程的**发送寄存器 send**                                    |
| 0x0000004             | 0 号硬件线程的**发送状态寄存器 status**                              |
| 0x0000008             | 0 号硬件线程的**领取寄存器 claim**                                   |
| 0x000000C - 0x0000FFC | 保留                                                                 |
| 0x0001000             | 1 号硬件线程的**发送寄存器 send**                                    |
| 0x0001004             | 1 号硬件线程的**发送状态寄存器 status**                              |
| 0x0001008             | 1 号硬件线程的**领取寄存器 claim**                                   |
| 0x000100C - 0x0001FFC | 保留                                                                 |
| 0x0002000             | 2 号硬件线程的**发送寄存器 send**                                    |
| 0x0002004             | 2 号硬件线程的**发送状态寄存器 status**                              |
| 0x0002008             | 2 号硬件线程的**领取寄存器 claim**                                   |
| 0x000200C - 0x0002FFC | 保留                                                                 |
| ...                   | ...                                                                  |
| 0x0FFE000             | 4094 号硬件线程的**发送寄存器 send**                                 |
| 0x0FFE004             | 4094 号硬件线程的**发送状态寄存器 status**                           |
| 0x0FFE008             | 4094 号硬件线程的**领取寄存器 claim**                                |
| 0x0FFE00C - 0x0FFEFFC | 保留                                                                 |
| 0x0FFF000 - 0x0FFFFFC | 保留                                                                 |
| 0x1000000             | 0 号硬件线程的**UIID 寄存器 uiid**                                   |
| 0x1000004             | 0 号硬件线程的**撤回寄存器 withdraw**                                |
| 0x1000008             | 0 号硬件线程的**接收屏蔽寄存器 recv_disable**                        |
| 0x100000C - 0x10007FC | 保留                                                                 |
| 0x1000800             | 0 号硬件线程作为发送方的**使能寄存器 enable**，接收方 0 - 31         |
| 0x1000804             | 0 号硬件线程作为发送方的**使能寄存器 enable**，接收方 32 - 63        |
| 0x1000808             | 0 号硬件线程作为发送方的**使能寄存器 enable**，接收方 64 - 95        |
| ...                   | ...                                                                  |
| 0x10009FC             | 0 号硬件线程作为发送方的**使能寄存器 enable**，接收方 4096 - 4094    |
| 0x1000A00             | 0 号硬件线程作为接收方的**使能寄存器 enable**，发送方 0 - 31         |
| 0x1000A04             | 0 号硬件线程作为接收方的**使能寄存器 enable**，发送方 32 - 63        |
| 0x1000A08             | 0 号硬件线程作为接收方的**使能寄存器 enable**，发送方 64 - 95        |
| ...                   | ...                                                                  |
| 0x1000BFC             | 0 号硬件线程作为接收方的**使能寄存器 enable**，发送方 4096 - 4094    |
| 0x1000C00 - 0x1000FFC | 保留                                                                 |
| 0x1001000             | 1 号硬件线程的**UIID 寄存器 uiid**                                   |
| 0x1001004             | 1 号硬件线程的**撤回寄存器 withdraw**                                |
| 0x1001008             | 1 号硬件线程的**接收屏蔽寄存器 recv_disable**                        |
| 0x100100C - 0x10017FC | 保留                                                                 |
| 0x1001800             | 1 号硬件线程作为发送方的**使能寄存器 enable**，接收方 0 - 31         |
| 0x1001804             | 1 号硬件线程作为发送方的**使能寄存器 enable**，接收方 32 - 63        |
| 0x1001808             | 1 号硬件线程作为发送方的**使能寄存器 enable**，接收方 64 - 95        |
| ...                   | ...                                                                  |
| 0x10019FC             | 1 号硬件线程作为发送方的**使能寄存器 enable**，接收方 4096 - 4094    |
| 0x1001A00             | 1 号硬件线程作为接收方的**使能寄存器 enable**，发送方 0 - 31         |
| 0x1001A04             | 1 号硬件线程作为接收方的**使能寄存器 enable**，发送方 32 - 63        |
| 0x1001A08             | 1 号硬件线程作为接收方的**使能寄存器 enable**，发送方 64 - 95        |
| ...                   | ...                                                                  |
| 0x1001BFC             | 1 号硬件线程作为接收方的**使能寄存器 enable**，发送方 4096 - 4094    |
| 0x1002000             | 2 号硬件线程的**UIID 寄存器 uiid**                                   |
| 0x1002004             | 2 号硬件线程的**撤回寄存器 withdraw**                                |
| 0x1002008             | 2 号硬件线程的**接收屏蔽寄存器 recv_disable**                        |
| 0x100200C - 0x10027FC | 保留                                                                 |
| 0x1002800             | 2 号硬件线程作为发送方的**使能寄存器 enable**，接收方 0 - 31         |
| 0x1002804             | 2 号硬件线程作为发送方的**使能寄存器 enable**，接收方 32 - 63        |
| 0x1002808             | 2 号硬件线程作为发送方的**使能寄存器 enable**，接收方 64 - 95        |
| ...                   | ...                                                                  |
| 0x10029FC             | 2 号硬件线程作为发送方的**使能寄存器 enable**，接收方 4096 - 4094    |
| 0x1002A00             | 2 号硬件线程作为接收方的**使能寄存器 enable**，发送方 0 - 31         |
| 0x1002A04             | 2 号硬件线程作为接收方的**使能寄存器 enable**，发送方 32 - 63        |
| 0x1002A08             | 2 号硬件线程作为接收方的**使能寄存器 enable**，发送方 64 - 95        |
| ...                   | ...                                                                  |
| 0x1002BFC             | 2 号硬件线程作为接收方的**使能寄存器 enable**，发送方 4096 - 4094    |
| 0x1002C00 - 0x1002FFC | 保留                                                                 |
| ...                   | ...                                                                  |
| 0x1FFE000             | 4094 号硬件线程的**UIID 寄存器 uiid**                                |
| 0x1FFE004             | 4094 号硬件线程的**撤回寄存器 withdraw**                             |
| 0x1FFE008             | 4094 号硬件线程的**接收屏蔽寄存器 recv_disable**                     |
| 0x1FFE00C - 0x1FFE7FC | 保留                                                                 |
| 0x1FFE800             | 4094 号硬件线程作为发送方的**使能寄存器 enable**，接收方 0 - 31      |
| 0x1FFE804             | 4094 号硬件线程作为发送方的**使能寄存器 enable**，接收方 32 - 63     |
| 0x1FFE808             | 4094 号硬件线程作为发送方的**使能寄存器 enable**，接收方 64 - 95     |
| ...                   | ...                                                                  |
| 0x1FFE9FC             | 4094 号硬件线程作为发送方的**使能寄存器 enable**，接收方 4096 - 4094 |
| 0x1FFEA00             | 4094 号硬件线程作为接收方的**使能寄存器 enable**，发送方 0 - 31      |
| 0x1FFEA04             | 4094 号硬件线程作为接收方的**使能寄存器 enable**，发送方 32 - 63     |
| 0x1FFEA08             | 4094 号硬件线程作为接收方的**使能寄存器 enable**，发送方 64 - 95     |
| ...                   | ...                                                                  |
| 0x1FFEBFC             | 4094 号硬件线程作为接收方的**使能寄存器 enable**，发送方 4096 - 4094 |
| 0x1FFEC00 - 0x1FFEFFC | 保留                                                                 |
| 0x1FFF000             | **缓冲区出队发送方 UIID 寄存器 fifo_pop_send**                       |
| 0x1FFF004             | **缓冲区出队接收方 UIID 寄存器 fifo_pop_recv**                       |
| 0x1FFF008 - 0x1FFFFFC | 保留                                                                 |

## 寄存器读写细节

### UIID 寄存器 uiid

考虑硬件线程 `i` 的 UIID 寄存器。读写此寄存器时直接从 `uiid[i]` 读出或写入 `uiid[i]`。

### 使能寄存器 enable

使能寄存器分按发送方和按接收方排列的两部分。通过两部分读写，实际读写的硬件值相同，即在两部分读相同发送方和接收方对应的位读出的值相同，写入相同发送方和接收方对应的位效果相同。

对于按发送方排列的部分，考虑发送方 `s` 的第 `i` 个地址的 32 位 `enable` 寄存器，即地址偏移为 `0x1000000 + s × 0x1800 + i × 4` 的 32 位寄存器。若不考虑不在 `0` 到 `n - 1` 间的情况，此寄存器覆盖的接收方编号范围为 `32 × i` 到 `32 × i + 31`。

写入时，对于写入数据的第 `j` 位，对应的接收方编号为 `r = 32 × i + j`。

- 如果 `r` 在 `0` 到 `n - 1` 间，则置 `enable[s][r]` 为写入的第 `j` 位。
- 否则，第 `j` 位被忽略。

读取时，对于读出数据的第 `j` 位，对应的接收方编号同样为 `r = 32 × i + j`。

- 如果 `r` 在 `0` 到 `n - 1` 间，读出的第 `j` 位为 `enable[s][r]`。
- 否则，第 `j` 位为 `0`。

对于按接收方排列的部分，考虑接收方 `r` 的第 `i` 个地址的 32 位 `enable` 寄存器，即地址偏移为 `0x1000000 + r × 0x1800 + i × 4` 的 32 位寄存器。若不考虑不在 `0` 到 `n - 1` 间的情况，此寄存器覆盖的接收方编号范围为 `32 × i` 到 `32 × i + 31`。

写入时，对于写入数据的第 `j` 位，对应的发送方编号为 `s = 32 × i + j`。

- 如果 `s` 在 `0` 到 `n - 1` 间，则置 `enable[s][r]` 为写入的第 `j` 位。
- 否则，第 `j` 位被忽略。

读取时，对于读出数据的第 `j` 位，对应的接收方编号同样为 `s = 32 × i + j`。

- 如果 `s` 在 `0` 到 `n - 1` 间，读出的第 `j` 位为 `enable[s][r]`。
- 否则，第 `j` 位为 `0`。

### 发送状态寄存器 status

考虑发送方 `s` 的发送状态寄存器。

读取此寄存器时，返回结果的第 `0` 位为 `status[s]`，其余位为 `0`。

写入此寄存器所在地址的效果见[发送寄存器 send](#发送寄存器-send)。

### 发送寄存器 send

考虑发送方 `s` 的发送寄存器。

写入此寄存器时，设写入的值为 `u`。如果对于 `0` 到 `n - 1` 中的 `r`，存在任意一个 `r` 使得 `uiid[r]` 等于 `u`，则说明 `u` 对应的接收方进程在硬件线程 `r` 上运行。此时

- 如果 `enable[s][r]` 为 `0`，发送失败，置 `status[s]` 为 `0`。
- 否则置 `pending[s][r]` 为 `1`，发送成功，置 `status[s]` 为 `1`。

如果没有找到这样的 `r`，则说明 `u` 对应的接收方进程不再运行，此时

- 如果缓冲区响应此次写入，将 `uiid[s]` 作为发送方 UIID、`u` 作为接收方 UIID 填入缓冲区，发送成功，置 `status[s]` 为 `1`。
- 如果缓冲区不响应此次写入（例如缓冲区中 FIFO 已满），置 `status[s]` 为 `0`。

> TODO

读取此寄存器所在地址的效果见[发送状态寄存器 status](#发送状态寄存器-status)

### 撤回寄存器 withdraw

考虑发送方 `s` 的撤回寄存器。

读取此寄存器值时：

- 如果对于 `0` 到 `n - 1`，存在 `r` 使得 `pending[s][r]` 为 `1`，则读出的值为任意这样的 `r` 对应的 `uiid[r]`。对于这个 `r`，置 `pending[s][r]` 为 `0`，撤回此中断。
- 否则不存在这样的 `r`，读出的值为 `0xFFFFFFFF`。

> `0xFFFFFFFF` 可以被视作有符号整数 `-1`，下同。

> 即使 `enable[s][r]` 为 `0`，对应的中断仍能被撤回。

写入此寄存器的值会被忽略。

### 领取寄存器 claim

考虑接收方 `r` 的领取寄存器。

读取此寄存器值时：

- 如果对于 `0` 到 `n - 1`，存在 `s` 使得 `pending[s][r]` 为 `1`，则读出的值为任意这样的 `s` 对应的 `uiid[s]`。对于这个 `s`，置 `pending[s][r]` 为 `0`，领取此中断。
- 否则不存在这样的 `s`，读出的值为 `0xFFFFFFFF`。

> 即使 `enable[s][r]` 为 `0`，对应的中断仍能被领取。此情况仅在先发送了中断使 `pending[s][r]` 为 `1`，而后才设 `enable[s][r]` 为 `0` 的情况下才会出现。这样，用户进程时间片结束时，操作系统可以先写入接收屏蔽寄存器 recv_disable 停止中断接收，再反复 `claim` 以记录已被发送给此进程而尚未处理的中断。

写入此寄存器的值会被忽略。

### 接收屏蔽寄存器 recv_disable

考虑接收方 `s` 的接收使能寄存器。

写入此寄存器时：

- 如果写入的值最低位为 `1`，无事发生。
- 如果写入的值最低位为 `0`，对于所有 `0` 到 `n - 1` 的 `r`，置 `enable[r][s]` 为 `0`。

读取此寄存器得到的值应被忽略。

### 缓冲区出队发送方 UIID 寄存器 fifo_pop_send

读取此寄存器时：

- 如果缓冲区为空，则返回 `0xFFFFFFFF`。
- 否则，缓冲区中一条记录的发送方 UIID 被返回，这条记录被从缓冲区移出。

写入此寄存器的值会被忽略。

### 缓冲区出队接收方 UIID 寄存器 fifo_pop_recv

读取此寄存器时：

- 如果缓冲区为空，则返回 `0xFFFFFFFF`。
- 否则，缓冲区中一条记录的接收 UIID 被返回。保证此条记录和下次缓冲区出队接收方 UIID 寄存器读出的值为同一条记录。

> 32 位软件可先读接收方 UIID、再读接收方 UIID 以读出一条完整记录。64 位软件可一次读取出发送方和接收方 UIID。

写入此寄存器的值会被忽略。

## CSR 中 USIP 的设置

CSR `xip` 中的 USIP 位应为一可读可写位。USIP 可被软件写入，除此之外，对于编号为 `s` 的硬件线程，如果存在 `r` 使得 `pending[r][s]` 为 `1`，则中断控制器发出软件中断，置 USIP 为 `1`。USIP 的真实值为软件写入的值和中断控制器生成值之或（OR）。因此，如果中断控制器不发出软件中断，可以通过向 USIP 写入 `0` 清除软件中断。否则如果中断控制器在发出软件中断，向 USIP 写入 `0` 将不会清除软件中断，读出的值仍为 `1`。只有领取中断才能清除中断控制器给出的值。

> TODO: 检查 `xip` 在何特权级可读写。

## 软件流程

### 中断发送

1. 用户进程尝试向自己所在硬件线程的 `send` 写入接收方 UIID。
2. 如果用户进程关心发送是否成功，读取 `status`。如果为 `1`，发送成功，否则可以发起系统调用等，要求操作系统立即响应。

### 中断处理

如果确认是跨进程中断，读取所在硬件线程的 `claim` 获取中断来源。重复此过程，直到返回值为 `0xFFFFFFFF`，此时中断控制器不再置 USIP 为 `1`。

### 操作系统结束时间片

分别执行以下部分，将读取到的中断记录、分发。

- 设置当前硬件线程的 `uiid` 为无效值，如可保留 `0xFFFFFFFF` 表示不存在的 UIID。
- 撤回已由此硬件线程发送但尚未接收方被处理的中断。具体来说，
  1. 反复读取 `withdraw`，读出已发送但未被接收方处理的中断，直到返回值为 `0xFFFFFFFF`。
- 记录已发送到此硬件线程但尚未被处理的中断。具体来说，
  1. 向 `recv_disable` 写入 `0`，屏蔽所有发送方到此硬件线程的使能。
  2. 反复读取 `clear`，读出已被发送方发送但未处理的中断，直到返回值为 `0xFFFFFFFF`。
- 反复依次读取 `fifo_pop_send` 和 `fifo_pop_clear`，获取缓冲区中各进程间发送的中断，直到任意一者返回值为 `0xFFFFFFFF`。
- 记录 `status`，待恢复此进程时写入。

### 操作系统开始时间片

1. 设置当前硬件线程的 `uiid` 为用户进程的 UIID。
2. 设置当前硬件线程的 `status` 为用户进程之前的 `status`。
3. 设置与当前用户进程相关的合适的 `enable`。可以分别通过按发送方排列的部分和按接收方排列的部分设置当前进程发送和接收中断的使能。
4. 将当前硬件线程对应的 `send` `status` 和 `claim` 对应的物理页映射到用户地址空间固定位置，使得用户进程可以始终访问此虚拟地址。
5. 转到用户态，发放当前进程之前接收到的中断。
