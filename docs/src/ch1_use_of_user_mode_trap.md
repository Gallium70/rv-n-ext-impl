# 用户态中断的使用

> 本节描述构想中的用户态中断的使用，部分功能细节仍在进一步讨论中

## 需要解决的问题

在一个成熟的操作系统中，同时运行的用户态进程数量是十分庞大的。在传统的实现方案中，这些用户态进程互相之间通信或与外设通信都需要经过内核态，这造成了大量的页表切换等颇具开销的行为。如果可以让用户态进程自己处理不需要内核态权限的中断，应能减少相应的开销，使得操作系统的性能得到提升。

此外，许多需要用户态进程处理的中断并不需要即时处理，引入用户态中断的机制可以在用户态进程被调度的时候再触发，减少对执行情况的干扰。

## 陷入信息表

为解决用户态进程数量过多且不同用户态进程有不同的用户态中断处理程序和中断信息，需添加进程的“陷入信息表” (Trap Information Table, TIT)。其结构和进程控制块的关系如下图：

![trap info table](assets/TIT.drawio.svg)

内核态维护一个先入先出的“陷入信息队列”，当有新的陷入信息时，将其添加至队列的尾部；而在用户态进程被调度时，内核态检查发现有陷入信息时，将相应信息恢复至寄存器，并设置 `uip` 寄存器。在返回至用户态后，立即触发中断，进入用户态进程自己设定的用户态中断处理程序。

`utval` 寄存器存储中断的具体信息，其结构为：

```
+-----+------+-----------+
| TAG | TYPE | trap info |
+-----+------+-----------+
```

`TAG` 用于记录中断是传递给哪个进程，`TYPE` 用于进一步区分中断的类别，`trap info` 则存储中断的更为详细的信息。

## 中断的响应

### 即时的中断响应

用户态可能接收到并即时处理的中断有时钟中断、外部中断以及自行设置的软件中断。当中断发生时，会执行以下步骤：

0. 硬件设置用户态寄存器。
1. 检查将要写入 `utval` 的值中的 `TAG` 是否为当前正在运行的进程。如果是，触发用户态中断，执行与恢复；如果不是，触发 S 态中断。
2. 进入 S 态中断，根据 `TAG` 将用户态 CSR 中的值存储在对应进程的 `TIT` 中，恢复并继续执行原用户态进程。该中断转为另一进程的“非即时中断”。

### 非即时的中断响应

一个进程存在非即时的中断需要响应，即在被调度时其 `TIT` 非空。操作系统依序执行以下步骤：

0. 欲调度该进程，检查 `TIT` ，发现存在需要处理的陷入信息。
1. 内核态构造 `trap frame` ，将 `trap info` 中的 `ucause` 和 `utval` 放入 `trap frame` 中，并设置 `uip` 中对应位，设置 `ustatus.UPIE`。使用 `uret` 返回用户态
2. `uret` 根据 `utatus.UPIE` 设置 `ustatus.UIE` ，用户态中断全局使能被开启。
3. 触发用户态中断，进入 `utvec` 对应的用户态中断处理程序，保存现场。
4. 查看 `ucause` 和 `utval` ，选择对应的处理分支。
5. 处理完成后，恢复现场，恢复用户态进程的运行。

## 应用示例

### 跨进程“信号”示例

假设在一个单核、支持 N 扩展的 CPU 上运行一支持用户态中断的操作系统，有进程 A 和进程 B，且有某种机制使它们互相知道彼此的 `pid`。

1. 进程 A 执行 `ecall` ，触发内核态中断，并通过寄存器 `a0-a7` 传递参数：跨进程信号，发送目标 B，传递信息 `0x1`。
2. 进入内核态中断处理程序 `ecall` 分支，根据寄存器值判断为“跨进程信号”，开始构造 B 的 `trap info`：
   - 构造 `utval`：`| TAG::B_pid | TYPE::cross_process_signal | trap_info ( src_pid: A_pid, info: 0x1 ) |`
   - 构造 `uip`：`| 0x0 | USIP ( 1 ) | 0x0 |` (挂起用户态软件中断)
   - 构造 `ucause`: `0x8000_0000_0000_0000` (用户态软件中断)
3. 将 `trap info` 存入 B 的 `TIT`，恢复 A 的运行。
4. 时间片轮转或 A 主动让权，开始调度 B。
5. 内核态检查 `TIT` 非空，开始构建 `trap frame`：
   - 根据 `PCB` 中的 `Trap Context` ，设置寄存器 `x1-x31` `utvec` `uie` `ustatus` `uepc`
   - 从 `PCB` 指向的 `TIT` 取出第一个 `trap info` ，根据内容设置寄存器 `utval` `uip` `ucause`
6. 使用 `uret` 恢复进入用户态：
   - 通过 `pc = uepc` 恢复为上次运行时间片最后的 `pc`
   - 通过 `ustatus.UIE = ustatus.UPIE` 开启用户态中断全局使能，允许中断发生
7. 中断发生，跳转 `utvec` 对应的用户态中断处理程序，保存现场。
8. 通过查看 `utval` 和 `ucause` 知道是来自 A 的跨进程信号，进入相应分支处理。
9. 处理完毕，恢复现场，继续执行 B 进程。
